diff --git a/app/hello/hello_traits.h b/app/hello/hello_traits.h
index 5328337..608ba90 100644
--- a/app/hello/hello_traits.h
+++ b/app/hello/hello_traits.h
@@ -21,7 +21,7 @@ template<> struct Traits<Build>: public Traits_Tokens
     static const bool enabled = true;
     static const bool monitored = true;
     static const bool debugged = true;
-    static const bool hysterically_debugged = false;
+    static const bool hysterically_debugged = true;
 
     // Default aspects
     typedef ALIST<> ASPECTS;
diff --git a/include/architecture/rv64/rv64_cpu.h b/include/architecture/rv64/rv64_cpu.h
index a805611..fff0c1d 100644
--- a/include/architecture/rv64/rv64_cpu.h
+++ b/include/architecture/rv64/rv64_cpu.h
@@ -55,7 +55,15 @@ public:
         TVM             = 1 << 20,      // Trap Virtual Memory makes SATP inaccessible in supervisor mode
         TW              = 1 << 21,      // Timeout Wait for WFI outside machine mode
         TSR             = 1 << 22,      // Trap SRet in supervisor mode
-        SD              = 1 << 31,      // Status Dirty = (FS | XS)
+        SXL             = 3UL << 32,      // XLEN for S-mode
+        SXL_32          = 1UL << 32,      // XLEN for S-mode 32 bits
+        SXL_64          = 2UL << 32,      // XLEN for S-mode 64 bits
+        SXL_128         = 3UL << 32,      // XLEN for S-mode 128 bits
+        UXL             = 3UL << 34,      // XLEN for S-mode
+        UXL_32          = 1UL << 34,      // XLEN for U-mode 32 bits
+        UXL_64          = 2UL << 34,      // XLEN for U-mode 64 bits
+        UXL_128         = 3UL << 34,      // XLEN for U-mode 128 bits
+        SD              = 1UL << 63,      // Status Dirty = (FS | XS)
     };
 
     // Interrupt-Enable, Interrupt-Pending and Machine Cause Registers ([m|s]ie, [m|s]ip, and [m|s]cause when interrupt bit is set)
@@ -417,89 +425,86 @@ inline void CPU::Context::push(bool interrupt)
 
 if(interrupt) {
     ASM("       csrr     x3,    mepc            \n"
-        "       sw       x3,    0(sp)           \n");   // push MEPC as PC on interrupts
+        "       sd       x3,    0(sp)           \n");   // push MEPC as PC on interrupts
 } else {
-    ASM("       sw       x1,    0(sp)           \n");   // push RA as PC on context switches
+    ASM("       sd       x1,    0(sp)           \n");   // push RA as PC on context switches
 }
-
-    ASM("       csrr     x3,  mstatus           \n");
-
-    ASM("       sw       x3,    4(sp)           \n"     // push ST
-        "       sw       x1,    8(sp)           \n"     // push RA
-        "       sw       x5,   12(sp)           \n"     // push x5-x31
-        "       sw       x6,   16(sp)           \n"
-        "       sw       x7,   20(sp)           \n"
-        "       sw       x8,   24(sp)           \n"
-        "       sw       x9,   28(sp)           \n"
-        "       sw      x10,   32(sp)           \n"
-        "       sw      x11,   36(sp)           \n"
-        "       sw      x12,   40(sp)           \n"
-        "       sw      x13,   44(sp)           \n"
-        "       sw      x14,   48(sp)           \n"
-        "       sw      x15,   52(sp)           \n"
-        "       sw      x16,   56(sp)           \n"
-        "       sw      x17,   60(sp)           \n"
-        "       sw      x18,   64(sp)           \n"
-        "       sw      x19,   68(sp)           \n"
-        "       sw      x20,   72(sp)           \n"
-        "       sw      x21,   76(sp)           \n"
-        "       sw      x22,   80(sp)           \n"
-        "       sw      x23,   84(sp)           \n"
-        "       sw      x24,   88(sp)           \n"
-        "       sw      x25,   92(sp)           \n"
-        "       sw      x26,   96(sp)           \n"
-        "       sw      x27,  100(sp)           \n"
-        "       sw      x28,  104(sp)           \n"
-        "       sw      x29,  108(sp)           \n"
-        "       sw      x30,  112(sp)           \n"
-        "       sw      x31,  116(sp)           \n");
+    ASM("       csrr     x3,  mstatus            \n");
+    ASM("       sd       x3,     8(sp)           \n");     // push ST
+    ASM("       sd       x1,    16(sp)           \n");     // push RA
+    ASM("       sd       x5,    24(sp)           \n");     // push x5-x31
+    ASM("       sd       x6,    32(sp)           \n");
+    ASM("       sd       x7,    40(sp)           \n");
+    ASM("       sd       x8,    48(sp)           \n");
+    ASM("       sd       x9,    56(sp)           \n");
+    ASM("       sd      x10,    64(sp)           \n");
+    ASM("       sd      x11,    72(sp)           \n");
+    ASM("       sd      x12,    80(sp)           \n");
+    ASM("       sd      x13,    88(sp)           \n");
+    ASM("       sd      x14,    96(sp)           \n");
+    ASM("       sd      x15,   104(sp)           \n");
+    ASM("       sd      x16,   112(sp)           \n");
+    ASM("       sd      x17,   120(sp)           \n");
+    ASM("       sd      x18,   128(sp)           \n");
+    ASM("       sd      x19,   136(sp)           \n");
+    ASM("       sd      x20,   144(sp)           \n");
+    ASM("       sd      x21,   152(sp)           \n");
+    ASM("       sd      x22,   160(sp)           \n");
+    ASM("       sd      x23,   168(sp)           \n");
+    ASM("       sd      x24,   176(sp)           \n");
+    ASM("       sd      x25,   184(sp)           \n");
+    ASM("       sd      x26,   192(sp)           \n");
+    ASM("       sd      x27,   200(sp)           \n");
+    ASM("       sd      x28,   208(sp)           \n");
+    ASM("       sd      x29,   216(sp)           \n");
+    ASM("       sd      x30,   224(sp)           \n");
+    ASM("       sd      x31,   232(sp)           \n");
 }
 
 inline void CPU::Context::pop(bool interrupt)
 {
-    ASM("       lw       x3,    0(sp)           \n");   // pop PC into TMP
+    ASM("       ld       x3,    0(sp)           \n");   // pop PC into TMP
 if(interrupt) {
     ASM("       add      x3, x3, a0             \n");   // a0 is set by exception handlers to adjust [M|S]EPC to point to the next instruction if needed
 }
     ASM("       csrw     mepc, x3               \n");   // MEPC = PC
 
-    ASM("       lw       x3,    4(sp)           \n");   // pop ST into TMP
+    ASM("       ld       x3,    8(sp)           \n");   // pop ST into TMP
 if(!interrupt) {
     ASM("       li       a0, 3 << 11            \n"     // use a0 as a second TMP, since it will be restored later
         "       or       x3, x3, a0             \n");   // mstatus.MPP is automatically cleared on mret, so we reset it to MPP_M here
 }
-
-    ASM("       lw       x1,    8(sp)           \n"     // pop RA
-        "       lw       x5,   12(sp)           \n"     // pop x5-x31
-        "       lw       x6,   16(sp)           \n"
-        "       lw       x7,   20(sp)           \n"
-        "       lw       x8,   24(sp)           \n"
-        "       lw       x9,   28(sp)           \n"
-        "       lw      x10,   32(sp)           \n"
-        "       lw      x11,   36(sp)           \n"
-        "       lw      x12,   40(sp)           \n"
-        "       lw      x13,   44(sp)           \n"
-        "       lw      x14,   48(sp)           \n"
-        "       lw      x15,   52(sp)           \n"
-        "       lw      x16,   56(sp)           \n"
-        "       lw      x17,   60(sp)           \n"
-        "       lw      x18,   64(sp)           \n"
-        "       lw      x19,   68(sp)           \n"
-        "       lw      x20,   72(sp)           \n"
-        "       lw      x21,   76(sp)           \n"
-        "       lw      x22,   80(sp)           \n"
-        "       lw      x23,   84(sp)           \n"
-        "       lw      x24,   88(sp)           \n"
-        "       lw      x25,   92(sp)           \n"
-        "       lw      x26,   96(sp)           \n"
-        "       lw      x27,  100(sp)           \n"
-        "       lw      x28,  104(sp)           \n"
-        "       lw      x29,  108(sp)           \n"
-        "       lw      x30,  112(sp)           \n"
-        "       lw      x31,  116(sp)           \n"
-        "       addi    sp, sp, %0              \n" : : "i"(sizeof(Context))); // complete the pops above by adjusting SP
-
-    ASM("       csrw    mstatus, x3             \n");   // MSTATUS = ST
+    ASM("       ld       x1,    16(sp)           \n"     // pop RA
+        "       ld       x5,    24(sp)           \n"     // pop x5-x31
+        "       ld       x6,    32(sp)           \n"
+        "       ld       x7,    40(sp)           \n"
+        "       ld       x8,    48(sp)           \n"
+        "       ld       x9,    56(sp)           \n"
+        "       ld      x10,    64(sp)           \n"
+        "       ld      x11,    72(sp)           \n"
+        "       ld      x12,    80(sp)           \n"
+        "       ld      x13,    88(sp)           \n"
+        "       ld      x14,    96(sp)           \n"
+        "       ld      x15,   104(sp)           \n"
+        "       ld      x16,   112(sp)           \n"
+        "       ld      x17,   120(sp)           \n"
+        "       ld      x18,   128(sp)           \n"
+        "       ld      x19,   136(sp)           \n"
+        "       ld      x20,   144(sp)           \n"
+        "       ld      x21,   152(sp)           \n"
+        "       ld      x22,   160(sp)           \n"
+        "       ld      x23,   168(sp)           \n"
+        "       ld      x24,   176(sp)           \n"
+        "       ld      x25,   184(sp)           \n"
+        "       ld      x26,   192(sp)           \n"
+        "       ld      x27,   200(sp)           \n"
+        "       ld      x28,   208(sp)           \n"
+        "       ld      x29,   216(sp)           \n"
+        "       ld      x30,   224(sp)           \n"
+        "       ld      x31,   232(sp)           \n"
+        "       addi    sp, sp, %0               \n" : : "i"(sizeof(Context))); // complete the pops above by adjusting SP
+
+    ASM("       csrw    mstatus, x3              \n");   // MSTATUS = ST
 }
 
 inline CPU::Reg64 htole64(CPU::Reg64 v) { return CPU::htole64(v); }
diff --git a/include/architecture/rv64/rv64_traits.h b/include/architecture/rv64/rv64_traits.h
index 5fccbba..251375f 100644
--- a/include/architecture/rv64/rv64_traits.h
+++ b/include/architecture/rv64/rv64_traits.h
@@ -11,7 +11,7 @@ template<> struct Traits<CPU>: public Traits<Build>
 {
     enum {LITTLE, BIG};
     static const unsigned int ENDIANESS         = LITTLE;
-    static const unsigned int WORD_SIZE         = 32;
+    static const unsigned int WORD_SIZE         = 64;
     static const unsigned int CLOCK             = 50000000;
     static const bool unaligned_memory_access   = false;
 };
diff --git a/include/architecture/rv64/rv64_tsc.h b/include/architecture/rv64/rv64_tsc.h
index 5ff20d0..07f3c92 100644
--- a/include/architecture/rv64/rv64_tsc.h
+++ b/include/architecture/rv64/rv64_tsc.h
@@ -20,8 +20,7 @@ private:
 
     // Registers offsets from CLINT_BASE
     enum {               // Description
-        MTIME  = 0xbff8, // Counter (lower 32 bits)
-        MTIMEH = 0xbffc  // Counter (upper 32 bits)
+        MTIME  = 0xbff8
     };
 
 public:
@@ -35,12 +34,12 @@ public:
     static Hertz frequency() { return CLOCK; }
     static PPB accuracy() { return ACCURACY; }
 
-    static Time_Stamp time_stamp() { return (CPU::Reg64(reg(MTIMEH)) << 32) | reg(MTIME); }
+    static Time_Stamp time_stamp() { return reg(MTIME); }
 
 private:
     static void init() {}
 
-    static volatile CPU::Reg32 & reg(unsigned int o) { return reinterpret_cast<volatile CPU::Reg32 *>(Memory_Map::CLINT_BASE)[o / sizeof(CPU::Reg32)]; }
+    static volatile CPU::Reg64 & reg(unsigned int o) { return reinterpret_cast<volatile CPU::Reg64 *>(Memory_Map::CLINT_BASE)[o / sizeof(CPU::Reg64)]; }
 };
 
 __END_SYS
diff --git a/include/machine/riscv/riscv_ic.h b/include/machine/riscv/riscv_ic.h
index 88d819c..9bb4f84 100644
--- a/include/machine/riscv/riscv_ic.h
+++ b/include/machine/riscv/riscv_ic.h
@@ -164,7 +164,7 @@ private:
 
     static void init();
 
-    static volatile CPU::Reg32 & reg(unsigned int o) { return reinterpret_cast<volatile CPU::Reg32 *>(Memory_Map::CLINT_BASE)[o / sizeof(CPU::Reg32)]; }
+    static volatile CPU::Reg64 & reg(unsigned int o) { return reinterpret_cast<volatile CPU::Reg64 *>(Memory_Map::CLINT_BASE)[o / sizeof(CPU::Reg64)]; }
 
 private:
     static Interrupt_Handler _int_vector[INTS];
diff --git a/include/machine/riscv/riscv_timer.h b/include/machine/riscv/riscv_timer.h
index e0d4e3c..ea8438d 100644
--- a/include/machine/riscv/riscv_timer.h
+++ b/include/machine/riscv/riscv_timer.h
@@ -77,7 +77,7 @@ public:
     void handler(const Handler & handler) { _handler = handler; }
 
 private:
-    static volatile CPU::Reg32 & reg(unsigned int o) { return reinterpret_cast<volatile CPU::Reg32 *>(Memory_Map::CLINT_BASE)[o / sizeof(CPU::Reg32)]; }
+    static volatile CPU::Reg64 & reg(unsigned int o) { return reinterpret_cast<volatile CPU::Reg64 *>(Memory_Map::CLINT_BASE)[o / sizeof(CPU::Reg64)]; }
 
     static void config(const Hertz & frequency) {
         reg(MTIMECMP) = reg(MTIME) + (CLOCK / frequency);
diff --git a/include/machine/riscv/sifive_e/sifive_e_memory_map.h b/include/machine/riscv/sifive_e/sifive_e_memory_map.h
index dc7ac89..9818c65 100644
--- a/include/machine/riscv/sifive_e/sifive_e_memory_map.h
+++ b/include/machine/riscv/sifive_e/sifive_e_memory_map.h
@@ -33,7 +33,7 @@ public:
         UART0_BASE      = 0x10013000,   // SiFive UART
         SPI0_BASE       = 0x10014000,   // SiFive-E SPI
         PWM0_BASE       = 0x10015000,   // SiFive-E GPIO
-        UART1_BASE      = 0x10023000,   // SiFive UART
+        UART1_BASE      = 0x10010000,   // SiFive UART
         SPI1_BASE       = 0x10034000,   // SiFive-E SPI
         PWM1_BASE       = 0x10025000,   // SiFive-E GPIO
         SPI2_BASE       = 0x10034000,   // SiFive-E SPI
diff --git a/makedefs b/makedefs
index 8e31376..0eb3081 100644
--- a/makedefs
+++ b/makedefs
@@ -101,8 +101,8 @@ ia32_COMP_PREFIX	:= /usr/bin/x86_64-linux-gnu-
 armv7_COMP_PREFIX	:= /usr/bin/arm-none-eabi-
 armv8_COMP_PREFIX	:= /usr/bin/aarch64-linux-gnu-
 rv32_COMP_PREFIX	:= /usr/local/rv32/bin/riscv32-unknown-linux-gnu-
-#rv64_COMP_PREFIX	:= /usr/local/rv64/bin/riscv64-unknown-linux-gnu-
-rv64_COMP_PREFIX    := /usr/local/rv32/bin/riscv32-unknown-linux-gnu-
+rv64_COMP_PREFIX	:= /usr/local/rv64/bin/riscv64-unknown-linux-gnu-
+# rv64_COMP_PREFIX    := /usr/local/rv32/bin/riscv32-unknown-linux-gnu-
 COMP_PREFIX		= $($(ARCH)_COMP_PREFIX)
 
 # Architecture specifics
@@ -198,7 +198,7 @@ riscv_CC_FLAGS		:= -march=rv32gc -mabi=ilp32f -Wl, -mno-relax
 riscv_AS_FLAGS		:= -march=rv32gc -mabi=ilp32f
 riscv_LD_FLAGS		:= -m elf32lriscv_ilp32f --no-relax
 riscv_EMULATOR		= qemu-system-riscv32 $(QEMU_DEBUG) -machine sifive_e -m $(MEM_SIZE)k -serial mon:stdio -bios none -nographic -no-reboot $(BOOT_ROM) -kernel 
-riscv_DEBUGGER		:= $(COMP_PREFIX)gdb
+riscv_DEBUGGER		:= gdb-multiarch -ex "set architecture riscv:rv32"
 riscv_FLASHER		:= 
 riscv_MAGIC		:= --nmagic
 riscv_CODE_NAME		:= .init
@@ -208,21 +208,22 @@ endif
 
 ifeq ($(MMOD),sifive_u)
 ifeq ($(ARCH),rv64)
-#riscv_CC_FLAGS		:= -march=rv64gc -mabi=lp64d -Wl, -mno-relax -mcmodel=medany
-#riscv_AS_FLAGS		:= -march=rv64gc -mabi=lp64d
-#riscv_LD_FLAGS		:= -m elf64lriscv_lp64f --no-relax
-#riscv_EMULATOR		= qemu-system-riscv64 $(QEMU_DEBUG) -machine sifive_u -smp 2 -m $(MEM_SIZE)k -serial mon:stdio -bios none -nographic -no-reboot $(BOOT_ROM) -kernel 
-riscv_CC_FLAGS      := -march=rv32gc -mabi=ilp32f -Wl, -mno-relax
-riscv_AS_FLAGS      := -march=rv32gc -mabi=ilp32f
-riscv_LD_FLAGS      := -m elf32lriscv_ilp32f --no-relax
-riscv_EMULATOR      = qemu-system-riscv32 $(QEMU_DEBUG) -machine sifive_u -cpu rv32 -smp 2 -m $(MEM_SIZE)k -serial mon:stdio -bios none -nographic -no-reboot $(BOOT_ROM) -kernel 
+riscv_CC_FLAGS		:= -march=rv64gc -mabi=lp64d -Wl, -mno-relax -mcmodel=medany
+riscv_AS_FLAGS		:= -march=rv64gc -mabi=lp64d
+riscv_LD_FLAGS		:= -m elf64lriscv_lp64f --no-relax
+riscv_EMULATOR		= qemu-system-riscv64 $(QEMU_DEBUG) -machine sifive_u -smp 2 -m $(MEM_SIZE)k -serial mon:stdio -bios none -nographic -no-reboot $(BOOT_ROM) -kernel 
+# riscv_EMULATOR		= qemu-system-riscv64 $(QEMU_DEBUG) -machine sifive_u -smp $(CPUS) -m $(MEM_SIZE)k -serial mon:stdio -bios none -nographic -no-reboot $(BOOT_ROM) -kernel 
+# riscv_CC_FLAGS      := -march=rv32gc -mabi=ilp32f -Wl, -mno-relax
+# riscv_AS_FLAGS      := -march=rv32gc -mabi=ilp32f
+# riscv_LD_FLAGS      := -m elf32lriscv_ilp32f --no-relax
+# riscv_EMULATOR      = qemu-system-riscv32 $(QEMU_DEBUG) -machine sifive_u -cpu rv32 -smp 2 -m $(MEM_SIZE)k -serial mon:stdio -bios none -nographic -no-reboot $(BOOT_ROM) -kernel 
 else
 riscv_CC_FLAGS      := -march=rv32gc -mabi=ilp32d -Wl, -mno-relax
 riscv_AS_FLAGS      := -march=rv32gc -mabi=ilp32d
 riscv_LD_FLAGS      := -m elf32lriscv_ilp32f --no-relax
-riscv_EMULATOR		= qemu-system-riscv32 $(QEMU_DEBUG) -machine virt -cpu rv32 -smp $(CPUS) -m $(MEM_SIZE)k -serial mon:stdio -bios none -nographic -no-reboot $(BOOT_ROM) -kernel 
+riscv_EMULATOR     = qemu-system-riscv32 $(QEMU_DEBUG) -machine sifive_u -cpu rv32 -smp 2 -m $(MEM_SIZE)k -serial mon:stdio -bios none -nographic -no-reboot -kernel  
 endif 
-riscv_DEBUGGER		:= $(COMP_PREFIX)gdb
+riscv_DEBUGGER		:= gdb-multiarch -ex "set architecture riscv:rv64"
 riscv_FLASHER		:= 
 riscv_MAGIC		:= --nmagic
 riscv_CODE_NAME		:= .init
diff --git a/src/architecture/rv64/rv64_cpu.cc b/src/architecture/rv64/rv64_cpu.cc
index 9ade785..67e2487 100644
--- a/src/architecture/rv64/rv64_cpu.cc
+++ b/src/architecture/rv64/rv64_cpu.cc
@@ -10,38 +10,38 @@ unsigned int CPU::_bus_clock;
 
 void CPU::Context::save() volatile
 {
-    ASM("       sw       x1,    0(a0)           \n"     // push RA as PC
-        "       csrr     x3,  mstatus           \n"
-        "       sw       x3,    4(a0)           \n"     // push ST
-        "       sw       x1,    8(a0)           \n"     // push RA
-        "       sw       x5,   12(a0)           \n"     // push x5-x31
-        "       sw       x6,   16(a0)           \n"
-        "       sw       x7,   20(a0)           \n"
-        "       sw       x8,   24(a0)           \n"
-        "       sw       x9,   28(a0)           \n"
-        "       sw      x10,   32(a0)           \n"
-        "       sw      x11,   36(a0)           \n"
-        "       sw      x12,   40(a0)           \n"
-        "       sw      x13,   44(a0)           \n"
-        "       sw      x14,   48(a0)           \n"
-        "       sw      x15,   52(a0)           \n"
-        "       sw      x16,   56(a0)           \n"
-        "       sw      x17,   60(a0)           \n"
-        "       sw      x18,   64(a0)           \n"
-        "       sw      x19,   68(a0)           \n"
-        "       sw      x20,   72(a0)           \n"
-        "       sw      x21,   76(a0)           \n"
-        "       sw      x22,   80(a0)           \n"
-        "       sw      x23,   84(a0)           \n"
-        "       sw      x24,   88(a0)           \n"
-        "       sw      x25,   92(a0)           \n"
-        "       sw      x26,   96(a0)           \n"
-        "       sw      x27,  100(a0)           \n"
-        "       sw      x28,  104(a0)           \n"
-        "       sw      x29,  108(a0)           \n"
-        "       sw      x30,  112(a0)           \n"
-        "       sw      x31,  116(a0)           \n"
-        "       ret                             \n");
+    ASM("       sd       x1,     0(a0)           \n");     // push RA as PC
+    ASM("       csrr     x3,   mstatus           \n");
+    ASM("       sd       x3,     8(sp)           \n");     // push ST
+    ASM("       sd       x1,    16(sp)           \n");     // push RA
+    ASM("       sd       x5,    24(sp)           \n");     // push x5-x31
+    ASM("       sd       x6,    32(sp)           \n");
+    ASM("       sd       x7,    40(sp)           \n");
+    ASM("       sd       x8,    48(sp)           \n");
+    ASM("       sd       x9,    56(sp)           \n");
+    ASM("       sd      x10,    64(sp)           \n");
+    ASM("       sd      x11,    72(sp)           \n");
+    ASM("       sd      x12,    80(sp)           \n");
+    ASM("       sd      x13,    88(sp)           \n");
+    ASM("       sd      x14,    96(sp)           \n");
+    ASM("       sd      x15,   104(sp)           \n");
+    ASM("       sd      x16,   112(sp)           \n");
+    ASM("       sd      x17,   120(sp)           \n");
+    ASM("       sd      x18,   128(sp)           \n");
+    ASM("       sd      x19,   136(sp)           \n");
+    ASM("       sd      x20,   144(sp)           \n");
+    ASM("       sd      x21,   152(sp)           \n");
+    ASM("       sd      x22,   160(sp)           \n");
+    ASM("       sd      x23,   168(sp)           \n");
+    ASM("       sd      x24,   176(sp)           \n");
+    ASM("       sd      x25,   184(sp)           \n");
+    ASM("       sd      x26,   192(sp)           \n");
+    ASM("       sd      x27,   200(sp)           \n");
+    ASM("       sd      x28,   208(sp)           \n");
+    ASM("       sd      x29,   216(sp)           \n");
+    ASM("       sd      x30,   224(sp)           \n");
+    ASM("       sd      x31,   232(sp)           \n");
+    ASM("       ret                              \n");
 }
 
 // Context load does not verify if interrupts were previously enabled by the Context's constructor
@@ -57,7 +57,7 @@ void CPU::switch_context(Context ** o, Context * n)     // "o" is in a0 and "n"
 {   
     // Push the context into the stack and update "o"
     Context::push();
-    ASM("sw sp, 0(a0)");   // update Context * volatile * o, which is in a0
+    ASM("sd sp, 0(a0)");   // update Context * volatile * o, which is in a0
 
     // Set the stack pointer to "n" and pop the context from the stack
     ASM("mv sp, a1");   // "n" is in a1
diff --git a/src/architecture/rv64/rv64_crt0.S b/src/architecture/rv64/rv64_crt0.S
index 576db99..a8d71ab 100644
--- a/src/architecture/rv64/rv64_crt0.S
+++ b/src/architecture/rv64/rv64_crt0.S
@@ -3,7 +3,7 @@
         .file "rv64_crt0.S"
 
         .section .text
-        .align  4
+        .align  8
         .global _start
         .type   _start, function
 _start:
@@ -11,14 +11,14 @@ _start:
         // BSS was cleared by SETUP
         call      _init
 
-        .align  4
+        .align  8
         .globl  __epos_app_entry
         .type   __epos_app_entry, function
 __epos_app_entry:
         // Main's stack was allocated by Thread::init()
         call    main
-        addi    sp, sp, -4
-        sw      a0, 0(sp)   // save main's return value to be used by exit()
+        addi    sp, sp, -8
+        sd      a0, 0(sp)   // save main's return value to be used by exit()
         call    _fini
-        lw      a0, 0(sp)
+        ld      a0, 0(sp)
         call    _exit
