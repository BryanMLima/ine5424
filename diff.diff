diff --git a/app/hello/hello_traits.h b/app/hello/hello_traits.h
index 5328337..21e1afd 100644
--- a/app/hello/hello_traits.h
+++ b/app/hello/hello_traits.h
@@ -10,16 +10,16 @@ template<> struct Traits<Build>: public Traits_Tokens
 {
     // Basic configuration
     static const unsigned int MODE = LIBRARY;
-    static const unsigned int ARCHITECTURE = RV64;
+    static const unsigned int ARCHITECTURE = RV32;
     static const unsigned int MACHINE = RISCV;
-    static const unsigned int MODEL = SiFive_U;
+    static const unsigned int MODEL = SiFive_E; 
     static const unsigned int CPUS = 1;
     static const unsigned int NODES = 1; // (> 1 => NETWORKING)
     static const unsigned int EXPECTED_SIMULATION_TIME = 60; // s (0 => not simulated)
 
     // Default flags
     static const bool enabled = true;
-    static const bool monitored = true;
+    static const bool monitored = false;
     static const bool debugged = true;
     static const bool hysterically_debugged = false;
 
diff --git a/app/philosophers_dinner/philosophers_dinner_traits.h b/app/philosophers_dinner/philosophers_dinner_traits.h
index 5328337..c0eef7c 100644
--- a/app/philosophers_dinner/philosophers_dinner_traits.h
+++ b/app/philosophers_dinner/philosophers_dinner_traits.h
@@ -10,16 +10,16 @@ template<> struct Traits<Build>: public Traits_Tokens
 {
     // Basic configuration
     static const unsigned int MODE = LIBRARY;
-    static const unsigned int ARCHITECTURE = RV64;
+    static const unsigned int ARCHITECTURE = RV32;
     static const unsigned int MACHINE = RISCV;
-    static const unsigned int MODEL = SiFive_U;
+    static const unsigned int MODEL = SiFive_E;
     static const unsigned int CPUS = 1;
     static const unsigned int NODES = 1; // (> 1 => NETWORKING)
     static const unsigned int EXPECTED_SIMULATION_TIME = 60; // s (0 => not simulated)
 
     // Default flags
     static const bool enabled = true;
-    static const bool monitored = true;
+    static const bool monitored = false;
     static const bool debugged = true;
     static const bool hysterically_debugged = false;
 
diff --git a/app/producer_consumer/producer_consumer_traits.h b/app/producer_consumer/producer_consumer_traits.h
index 5328337..c0eef7c 100644
--- a/app/producer_consumer/producer_consumer_traits.h
+++ b/app/producer_consumer/producer_consumer_traits.h
@@ -10,16 +10,16 @@ template<> struct Traits<Build>: public Traits_Tokens
 {
     // Basic configuration
     static const unsigned int MODE = LIBRARY;
-    static const unsigned int ARCHITECTURE = RV64;
+    static const unsigned int ARCHITECTURE = RV32;
     static const unsigned int MACHINE = RISCV;
-    static const unsigned int MODEL = SiFive_U;
+    static const unsigned int MODEL = SiFive_E;
     static const unsigned int CPUS = 1;
     static const unsigned int NODES = 1; // (> 1 => NETWORKING)
     static const unsigned int EXPECTED_SIMULATION_TIME = 60; // s (0 => not simulated)
 
     // Default flags
     static const bool enabled = true;
-    static const bool monitored = true;
+    static const bool monitored = false;
     static const bool debugged = true;
     static const bool hysterically_debugged = false;
 
diff --git a/include/architecture/ia32/ia32_cpu.h b/include/architecture/ia32/ia32_cpu.h
index 2f6ef80..f29ea33 100644
--- a/include/architecture/ia32/ia32_cpu.h
+++ b/include/architecture/ia32/ia32_cpu.h
@@ -344,7 +344,7 @@ public:
     static Reg fr() { return eax(); }
     static void fr(Reg r) { eax(r); }
 
-    static volatile unsigned int id() { return 0; }
+    static volatile unsigned int id();
     static unsigned int cores() { return 1; }
 
     static Hertz clock() { return _cpu_current_clock; }
@@ -409,6 +409,8 @@ public:
         return compare;
     }
 
+    static void smp_barrier(unsigned long cores = cores()) { CPU_Common::smp_barrier<&finc>(cores, id()); }
+
     // MMU operations
     static Reg  pd() { return cr3(); }
     static void pd(Reg r) { cr3(r); }
@@ -437,9 +439,9 @@ public:
 
     template<typename ... Tn>
     static Context * init_stack(Log_Addr usp, Log_Addr sp, void (* exit)(), int (* entry)(Tn ...), Tn ... an) {
-        // Multitasking scenarios use this method with USP != 0 for application threads, what causes two contexts to be pushed into the thread's stack.
+        // Multitasking scenarios use this method with USP != 0, what causes two contexts to be pushed into the thread's stack.
         // The context pushed first (and popped last) is the "regular" one, with entry pointing to the thread's entry point.
-        // The second context (popped first) is a dummy context that has first_dispatch as entry point. It is a system-level context (CPL=0),
+        // The second context (popped first) is a dummy context that has _int_leave as entry point. It is a system-level context (CPL=0),
         // so switch_context doesn't need to care for cross-level IRETs.
 
         sp -= SIZEOF<Tn ... >::Result;
diff --git a/include/architecture/ia32/ia32_pmu.h b/include/architecture/ia32/ia32_pmu.h
index 3c6d006..a066d5e 100644
--- a/include/architecture/ia32/ia32_pmu.h
+++ b/include/architecture/ia32/ia32_pmu.h
@@ -83,7 +83,7 @@ public:
     enum {
         // Event                         Select  UMask
         UNHALTED_CORE_CYCLES            = 0x3c | (0x00 << 8),
-        INSTRUCTIONS_RETIRED            = 0xc0 | (0x00 << 8),
+        COMMITED_INSTRUCTIONS           = 0xc0 | (0x00 << 8),
         UNHALTED_REFERENCE_CYCLES       = 0x3c | (0x01 << 8),
         LLC_REFERENCES                  = 0x2e | (0x4f << 8),
         LLC_MISSES                      = 0x2e | (0x41 << 8),
diff --git a/include/architecture/rv32/rv32_cpu.h b/include/architecture/rv32/rv32_cpu.h
index 54677eb..56daa87 100644
--- a/include/architecture/rv32/rv32_cpu.h
+++ b/include/architecture/rv32/rv32_cpu.h
@@ -5,6 +5,8 @@
 
 #include <architecture/cpu.h>
 
+extern "C" { void _int_leave(); }
+
 __BEGIN_SYS
 
 class CPU: protected CPU_Common
@@ -213,6 +215,7 @@ public:
     static void fr(Reg r) {  ASM("mv a0, %0" : : "r"(r) :); }
 
     static unsigned int id() { return 0; }
+
     static unsigned int cores() { return 1; }
 
     using CPU_Common::clock;
@@ -273,6 +276,8 @@ public:
         return old;
     }
 
+    static void smp_barrier(unsigned long cores = CPU::cores()) {}
+
     static void flush_tlb() {         ASM("sfence.vma"    : :           : "memory"); }
     static void flush_tlb(Reg addr) { ASM("sfence.vma %0" : : "r"(addr) : "memory"); }
 
@@ -300,6 +305,9 @@ public:
         sp -= sizeof(Context);
         Context * ctx = new(sp) Context(entry, exit);
         init_stack_helper(&ctx->_x10, an ...); // x10 is a0
+        sp -= sizeof(Context);
+        ctx = new(sp) Context(&_int_leave, 0); // this context will be popped by switch() to reach _int_leave(), which will activate the thread's context
+        ctx->_x10 = 0; // zero fr() for the pop(true) issued by _int_leave()
         return ctx;
     }
 
@@ -405,24 +413,24 @@ private:
 
 inline void CPU::Context::push(bool interrupt)
 {
-    ASM("       addi     sp, sp, %0             \n" : : "i"(-sizeof(Context))); // adjust SP for the pushes below
+    ASM("       addi    sp, sp, %0              \n" : : "i"(-sizeof(Context))); // adjust SP for the pushes below
 
 if(interrupt) {
-    ASM("       csrr     x3,    mepc            \n"
-        "       sw       x3,    0(sp)           \n");   // push MEPC as PC on interrupts
+    ASM("       csrr    x3,     mepc            \n"
+        "       sw      x3,     0(sp)           \n");   // push MEPC as PC on interrupts
 } else {
-    ASM("       sw       x1,    0(sp)           \n");   // push RA as PC on context switches
+    ASM("       sw      x1,     0(sp)           \n");   // push RA as PC on context switches
 }
 
-    ASM("       csrr     x3,  mstatus           \n");
+    ASM("       csrr    x3,  mstatus            \n");
 
-    ASM("       sw       x3,    4(sp)           \n"     // push ST
-        "       sw       x1,    8(sp)           \n"     // push RA
-        "       sw       x5,   12(sp)           \n"     // push x5-x31
-        "       sw       x6,   16(sp)           \n"
-        "       sw       x7,   20(sp)           \n"
-        "       sw       x8,   24(sp)           \n"
-        "       sw       x9,   28(sp)           \n"
+    ASM("       sw      x3,     4(sp)           \n"     // push ST
+        "       sw      x1,     8(sp)           \n"     // push RA
+        "       sw      x5,    12(sp)           \n"     // push x5-x31
+        "       sw      x6,    16(sp)           \n"
+        "       sw      x7,    20(sp)           \n"
+        "       sw      x8,    24(sp)           \n"
+        "       sw      x9,    28(sp)           \n"
         "       sw      x10,   32(sp)           \n"
         "       sw      x11,   36(sp)           \n"
         "       sw      x12,   40(sp)           \n"
@@ -449,16 +457,16 @@ if(interrupt) {
 
 inline void CPU::Context::pop(bool interrupt)
 {
-    ASM("       lw       x3,    0(sp)           \n");   // pop PC into TMP
+    ASM("       lw       x3, 0(sp)              \n");   // pop PC
 if(interrupt) {
     ASM("       add      x3, x3, a0             \n");   // a0 is set by exception handlers to adjust [M|S]EPC to point to the next instruction if needed
 }
     ASM("       csrw     mepc, x3               \n");   // MEPC = PC
 
-    ASM("       lw       x3,    4(sp)           \n");   // pop ST into TMP
+    ASM("       lw       x3,    4(sp)           \n");   // pop ST into x3 (tmp)
 if(!interrupt) {
-    ASM("       li       a0, 3 << 11            \n"     // use a0 as a second TMP, since it will be restored later
-        "       or       x3, x3, a0             \n");   // mstatus.MPP is automatically cleared on mret, so we reset it to MPP_M here
+    ASM("       li      a0, 3 << 11             \n"     // use a0 as a second TMP, since it will be restored later
+        "       or      x3, x3, a0              \n");   // mstatus.MPP is automatically cleared on mret, so we reset it to MPP_M here
 }
 
     ASM("       lw       x1,    8(sp)           \n"     // pop RA
@@ -491,7 +499,7 @@ if(!interrupt) {
         "       lw      x31,  116(sp)           \n"
         "       addi    sp, sp, %0              \n" : : "i"(sizeof(Context))); // complete the pops above by adjusting SP
 
-    ASM("       csrw    mstatus, x3             \n");   // MSTATUS = ST
+    ASM("       csrw    mstatus, x3             \n");   // mstatus = ST
 }
 
 inline CPU::Reg64 htole64(CPU::Reg64 v) { return CPU::htole64(v); }
diff --git a/include/architecture/rv32/rv32_pmu.h b/include/architecture/rv32/rv32_pmu.h
index b2e4cb2..53d9fa1 100644
--- a/include/architecture/rv32/rv32_pmu.h
+++ b/include/architecture/rv32/rv32_pmu.h
@@ -101,7 +101,7 @@ public:
         write(channel, 0);
     }
 
-    static void init() {}
+    static void init();
 
 private:
     static Reg mcounteren(){ Reg reg; ASM("csrr %0, mcounteren" : "=r"(reg) :); return reg;}
diff --git a/include/architecture/rv64/rv64_cpu.h b/include/architecture/rv64/rv64_cpu.h
deleted file mode 100644
index 6fe3375..0000000
--- a/include/architecture/rv64/rv64_cpu.h
+++ /dev/null
@@ -1,518 +0,0 @@
-// EPOS RISC-V 64 CPU Mediator Declarations
-
-#ifndef __rv64_h
-#define __rv64_h
-
-#include <architecture/cpu.h>
-
-__BEGIN_SYS
-
-class CPU: protected CPU_Common
-{
-    friend class Init_System; // for CPU::init()
-
-public:
-    // CPU Native Data Types
-    using CPU_Common::Reg8;
-    using CPU_Common::Reg16;
-    using CPU_Common::Reg32;
-    using CPU_Common::Reg64;
-    using CPU_Common::Reg;
-    using CPU_Common::Log_Addr;
-    using CPU_Common::Phy_Addr;
-
-    // Status Register ([m|s]status)
-    typedef Reg Status;
-    enum {
-        UIE             = 1 <<  0,      // User Interrupts Enabled
-        SIE             = 1 <<  1,      // Supervisor Interrupts Enabled
-        MIE             = 1 <<  3,      // Machine Interrupts Enabled
-        UPIE            = 1 <<  4,      // User Previous Interrupts Enabled
-        SPIE            = 1 <<  5,      // Supervisor Previous Interrupts Enabled
-        MPIE            = 1 <<  7,      // Machine Previous Interrupts Enabled
-        SPP             = 1 <<  8,      // Supervisor Previous Privilege
-        SPP_U           = 0 <<  8,      // Supervisor Previous Privilege = user
-        SPP_S           = 1 <<  8,      // Supervisor Previous Privilege = supervisor
-        MPP             = 3 << 11,      // Machine Previous Privilege
-        MPP_U           = 0 << 11,      // Machine Previous Privilege = user
-        MPP_S           = 1 << 11,      // Machine Previous Privilege = supervisor
-        MPP_M           = 3 << 11,      // Machine Previous Privilege = machine
-        FS              = 3 << 13,      // FPU Status
-        FS_OFF          = 0 << 13,      // FPU off
-        FS_INIT         = 1 << 13,      // FPU on
-        FS_CLEAN        = 2 << 13,      // FPU registers clean
-        FS_DIRTY        = 3 << 13,      // FPU registers dirty (and must be saved on context switch)
-        XS              = 3 << 15,      // Extension Status
-        XS_OFF          = 0 << 15,      // Extension off
-        XS_INIT         = 1 << 15,      // Extension on
-        XS_CLEAN        = 2 << 15,      // Extension registers clean
-        XS_DIRTY        = 3 << 15,      // Extension registers dirty (and must be saved on context switch)
-        MPRV            = 1 << 17,      // Memory PRiVilege (when set, enables MMU also in machine mode)
-        SUM             = 1 << 18,      // Supervisor User Memory access allowed
-        MXR             = 1 << 19,      // Make eXecutable Readable
-        TVM             = 1 << 20,      // Trap Virtual Memory makes SATP inaccessible in supervisor mode
-        TW              = 1 << 21,      // Timeout Wait for WFI outside machine mode
-        TSR             = 1 << 22,      // Trap SRet in supervisor mode
-        SD              = 1L<< 63      // Status Dirty = (FS | XS)
-    };
-
-    // Interrupt-Enable, Interrupt-Pending and Machine Cause Registers ([m|s]ie, [m|s]ip, and [m|s]cause when interrupt bit is set)
-    enum {
-        SSI             = 1 << 1,       // Supervisor Software Interrupt
-        MSI             = 1 << 3,       // Machine Software Interrupt
-        STI             = 1 << 5,       // Supervisor Timer Interrupt
-        MTI             = 1 << 7,       // Machine Timer Interrupt
-        SEI             = 1 << 9,       // Supervisor External Interrupt
-        MEI             = 1 << 11       // Machine External Interrupt
-    };
-
-    // Exceptions ([m|s]cause with interrupt = 0)
-    static const unsigned int EXCEPTIONS = 16;
-    enum {
-        EXC_IALIGN       = 0,   // Instruction address misaligned
-        EXC_IFAULT       = 1,   // Instruction access fault
-        EXC_IILLEGAL     = 2,   // Illegal instruction
-        EXC_BREAK        = 3,   // Breakpoint
-        EXC_DRALIGN      = 4,   // Load address misaligned
-        EXC_DRFAULT      = 5,   // Load access fault
-        EXC_DWALIGN      = 6,   // Store/AMO address misaligned
-        EXC_DWFAULT      = 7,   // Store/AMO access fault
-        EXC_ENVU         = 8,   // Environment call from U-mode
-        EXC_RES1         = 9,   // Environment call from S-mode
-        EXC_ENVH        = 10,   // reserved
-        EXC_ENVM        = 11,   // Environment call from M-mode
-        EXC_IPF         = 12,   // Instruction page fault
-        EXC_DPF         = 13,   // Data page fault
-        EXC_RES2        = 14,   // reserved
-        EXC_AMOPF       = 15,   // Store/AMO page fault
-    };
-
-    // CPU Context
-    class Context
-    {
-        friend class CPU;       // for Context::push() and Context::pop()
-        friend class IC;        // for Context::push() and Context::pop()
-        friend class Thread;    // for Context::push()
-
-    public:
-        Context() {}
-        // Contexts are loaded with [m|s]ret, which gets pc from [m|s]epc and updates some bits of [m|s]status, that's why _st is initialized with [M|S]PIE and [M|S]PP
-        // Kernel threads are created with usp = 0 and have SPP_S set
-        // Dummy contexts for the first execution of each thread (both kernel and user) are created with exit = 0 and SPIE cleared (no interrupts until the second context is popped)
-        Context(Log_Addr entry, Log_Addr exit): _pc(entry), _st((exit ? MPIE : 0) | MPP_M), _x1(exit) {
-            if(Traits<Build>::hysterically_debugged || Traits<Thread>::trace_idle) {
-                                                                        _x5 =  5;  _x6 =  6;  _x7 =  7;  _x8 =  8;  _x9 =  9;
-                _x10 = 10; _x11 = 11; _x12 = 12; _x13 = 13; _x14 = 14; _x15 = 15; _x16 = 16; _x17 = 17; _x18 = 18; _x19 = 19;
-                _x20 = 20; _x21 = 21; _x22 = 22; _x23 = 23; _x24 = 24; _x25 = 25; _x26 = 26; _x27 = 27; _x28 = 28; _x29 = 29;
-                _x30 = 30; _x31 = 31;
-            }
-        }
-
-        void save() volatile __attribute__ ((naked));
-        void load() const volatile __attribute__ ((naked));
-
-        friend OStream & operator<<(OStream & db, const Context & c) {
-            db << hex
-               << "{sp="   << &c
-               << ",pc="   << c._pc
-               << ",st="   << c._st
-               << ",lr="   << c._x1
-               << ",x5="   << c._x5
-               << ",x6="   << c._x6
-               << ",x7="   << c._x7
-               << ",x8="   << c._x8
-               << ",x9="   << c._x9
-               << ",x10="  << c._x10
-               << ",x11="  << c._x11
-               << ",x12="  << c._x12
-               << ",x13="  << c._x13
-               << ",x14="  << c._x14
-               << ",x15="  << c._x15
-               << ",x16="  << c._x16
-               << ",x17="  << c._x17
-               << ",x18="  << c._x18
-               << ",x19="  << c._x19
-               << ",x20="  << c._x20
-               << ",x21="  << c._x21
-               << ",x22="  << c._x22
-               << ",x23="  << c._x23
-               << ",x24="  << c._x24
-               << ",x25="  << c._x25
-               << ",x26="  << c._x26
-               << ",x27="  << c._x27
-               << ",x28="  << c._x28
-               << ",x29="  << c._x29
-               << ",x30="  << c._x30
-               << ",x31="  << c._x31
-               << "}" << dec;
-            return db;
-        }
-
-    private:
-        static void pop(bool interrupt = false);  // interrupt or context switch?
-        static void push(bool interrupt = false); // interrupt or context switch?
-
-    private:
-        Reg _pc;      // pc
-        Reg _st;      // [m|s]status
-    //  Reg _x0;      // zero
-        Reg _x1;      // ra, ABI Link Register
-    //  Reg _x2;      // sp, ABI Stack Pointer, saved as this
-    //  Reg _x3;      // gp, ABI Global Pointer, used in EPOS as a temporary
-    //  Reg _x4;      // tp, ABI Thread Pointer, used in EPOS as core id
-        Reg _x5;      // t0
-        Reg _x6;      // t1
-        Reg _x7;      // t2
-        Reg _x8;      // s0
-        Reg _x9;      // s1
-        Reg _x10;     // a0
-        Reg _x11;     // a1
-        Reg _x12;     // a2
-        Reg _x13;     // a3
-        Reg _x14;     // a4
-        Reg _x15;     // a5
-        Reg _x16;     // a6
-        Reg _x17;     // a7
-        Reg _x18;     // s2
-        Reg _x19;     // s3
-        Reg _x20;     // s4
-        Reg _x21;     // s5
-        Reg _x22;     // s6
-        Reg _x23;     // s7
-        Reg _x24;     // s8
-        Reg _x25;     // s9
-        Reg _x26;     // s10
-        Reg _x27;     // s11
-        Reg _x28;     // t3
-        Reg _x29;     // t4
-        Reg _x30;     // t5
-        Reg _x31;     // t6
-    };
-
-    // Interrupt Service Routines
-    typedef void (ISR)();
-
-    // Fault Service Routines (exception handlers)
-    typedef void (FSR)();
-
-public:
-    CPU() {};
-
-    static Log_Addr pc() { Reg r; ASM("auipc %0, 0" : "=r"(r) :); return r; }
-
-    static Reg sp() { Reg r; ASM("mv %0, sp" :  "=r"(r) :); return r; }
-    static void sp(Reg r) {  ASM("mv sp, %0" : : "r"(r) :); }
-
-    static Reg fp() { Reg r; ASM("mv %0, fp" :  "=r"(r) :); return r; }
-    static void fp(Reg r) {  ASM("mv fp, %0" : : "r"(r) :); }
-
-    static Reg ra() { Reg r; ASM("mv %0, ra" :  "=r"(r)); return r; }
-    static void ra(Reg r) {  ASM("mv ra, %0" : : "r"(r) :); }
-
-    static Reg fr() { Reg r; ASM("mv %0, a0" :  "=r"(r)); return r; }
-    static void fr(Reg r) {  ASM("mv a0, %0" : : "r"(r) :); }
-
-    static unsigned int id() { return 0; }
-    static unsigned int cores() { return 1; }
-
-    using CPU_Common::clock;
-    using CPU_Common::min_clock;
-    using CPU_Common::max_clock;
-    using CPU_Common::bus_clock;
-
-    static void int_enable()  { mint_enable(); }
-    static void int_disable() { mint_disable(); }
-    static bool int_enabled() { return (mstatus() & MIE); }
-    static bool int_disabled() { return !int_enabled(); }
-
-    static void halt() { ASM("wfi"); }
-
-    static void fpu_save();
-    static void fpu_restore();
-
-    static void switch_context(Context ** o, Context * n) __attribute__ ((naked));
-
-    template<typename T>
-    static T tsl(volatile T & lock) {
-        register T old;
-        register T one = 1;
-        ASM("1: lr.w    %0, (%1)        \n"
-            "   sc.w    t3, %2, (%1)    \n"
-            "   bnez    t3, 1b          \n" : "=&r"(old) : "r"(&lock), "r"(one) : "t3", "cc", "memory");
-        return old;
-    }
-
-    template<typename T>
-    static T finc(volatile T & value) {
-        register T old;
-        ASM("1: lr.w    %0, (%1)        \n"
-            "   addi    %0, %0, 1       \n"
-            "   sc.w    t3, %0, (%1)    \n"
-            "   bnez    t3, 1b          \n" : "=&r"(old) : "r"(&value) : "t3", "cc", "memory");
-        return old - 1;
-    }
-
-    template<typename T>
-    static T fdec(volatile T & value) {
-        register T old;
-        ASM("1: lr.w    %0, (%1)        \n"
-            "   addi    %0, %0, -1      \n"
-            "   sc.w    t3, %0, (%1)    \n"
-            "   bnez    t3, 1b          \n" : "=&r"(old) : "r"(&value) : "t3", "cc", "memory");
-        return old + 1;
-    }
-
-    template <typename T>
-    static T cas(volatile T & value, T compare, T replacement) {
-        register T old;
-        ASM("1: lr.w    %0, (%1)        \n"
-            "   bne     %0, %2, 2f      \n"
-            "   sc.w    t3, %3, (%1)    \n"
-            "   bnez    t3, 1b          \n"
-            "2:                         \n" : "=&r"(old) : "r"(&value), "r"(compare), "r"(replacement) : "t3", "cc", "memory");
-        return old;
-    }
-
-    static void flush_tlb() {         ASM("sfence.vma"    : :           : "memory"); }
-    static void flush_tlb(Reg addr) { ASM("sfence.vma %0" : : "r"(addr) : "memory"); }
-
-    using CPU_Common::htole64;
-    using CPU_Common::htole32;
-    using CPU_Common::htole16;
-    using CPU_Common::letoh64;
-    using CPU_Common::letoh32;
-    using CPU_Common::letoh16;
-
-    using CPU_Common::htobe64;
-    using CPU_Common::htobe32;
-    using CPU_Common::htobe16;
-    using CPU_Common::betoh64;
-    using CPU_Common::betoh32;
-    using CPU_Common::betoh16;
-
-    using CPU_Common::htonl;
-    using CPU_Common::htons;
-    using CPU_Common::ntohl;
-    using CPU_Common::ntohs;
-
-    template<typename ... Tn>
-    static Context * init_stack(Log_Addr usp, Log_Addr sp, void (* exit)(), int (* entry)(Tn ...), Tn ... an) {
-        sp -= sizeof(Context);
-        Context * ctx = new(sp) Context(entry, exit);
-        init_stack_helper(&ctx->_x10, an ...); // x10 is a0
-        return ctx;
-    }
-
-public:
-    // RISC-V 64 specifics
-    static Reg status()    { return mstatus(); }
-    static void status(Status st) { mstatus(st); }
-
-    static Reg tp() { Reg r; ASM("mv %0, x4" : "=r"(r) :); return r; }
-    static void tp(Reg r) {  ASM("mv x4, %0" : : "r"(r) :); }
-
-    static Reg a0() { Reg r; ASM("mv %0, a0" :  "=r"(r)); return r; }
-    static void a0(Reg r) {  ASM("mv a0, %0" : : "r"(r) :); }
-
-    static Reg a1() { Reg r; ASM("mv %0, a1" :  "=r"(r)); return r; }
-    static void a1(Reg r) {  ASM("mv a1, %0" : : "r"(r) :); }
-
-    static void ecall() { ASM("ecall"); }
-    static void iret() { mret(); }
-
-    // Machine mode
-    static void mint_enable()  { ASM("csrsi mstatus, %0" : : "i"(MIE) : "cc"); }
-    static void mint_disable() { ASM("csrci mstatus, %0" : : "i"(MIE) : "cc"); }
-
-    static Reg mhartid() { Reg r; ASM("csrr %0, mhartid" : "=r"(r) : : "memory", "cc"); return r & 0x3; }
-
-    static void mscratch(Reg r)   { ASM("csrw mscratch, %0" : : "r"(r) : "cc"); }
-    static Reg  mscratch() { Reg r; ASM("csrr %0, mscratch" :  "=r"(r) : : ); return r; }
-
-    static void mstatus(Reg r)   { ASM("csrw mstatus, %0" : : "r"(r) : "cc"); }
-    static Reg  mstatus() { Reg r; ASM("csrr %0, mstatus" :  "=r"(r) : : ); return r; }
-    static void mstatusc(Reg r)  { ASM("csrc mstatus, %0" : : "r"(r) : "cc"); }
-    static void mstatuss(Reg r)  { ASM("csrs mstatus, %0" : : "r"(r) : "cc"); }
-
-    static void mie(Reg r)   { ASM("csrw mie, %0" : : "r"(r) : "cc"); }
-    static void miec(Reg r)  { ASM("csrc mie, %0" : : "r"(r) : "cc"); }
-    static void mies(Reg r)  { ASM("csrs mie, %0" : : "r"(r) : "cc"); }
-    static Reg  mie() { Reg r; ASM("csrr %0, mie" :  "=r"(r) : : ); return r; }
-
-    static void mip(Reg r)   { ASM("csrw mip, %0" : : "r"(r) : "cc"); }
-    static void mipc(Reg r)  { ASM("csrc mip, %0" : : "r"(r) : "cc"); }
-    static void mips(Reg r)  { ASM("csrs mip, %0" : : "r"(r) : "cc"); }
-    static Reg  mip() { Reg r; ASM("csrr %0, mip" :  "=r"(r) : : ); return r; }
-
-    static Reg mcause() { Reg r; ASM("csrr %0, mcause" : "=r"(r) : : ); return r; }
-    static Reg mtval()  { Reg r; ASM("csrr %0, mtval" :  "=r"(r) : : ); return r; }
-
-    static void mepc(Reg r)   { ASM("csrw mepc, %0" : : "r"(r) : "cc"); }
-    static Reg  mepc() { Reg r; ASM("csrr %0, mepc" :  "=r"(r) : : ); return r; }
-
-    static void mret() { ASM("mret"); }
-
-    static void mideleg(Reg value) { ASM("csrw mideleg, %0" : : "r"(value) : "cc"); }
-    static void medeleg(Reg value) { ASM("csrw medeleg, %0" : : "r"(value) : "cc"); }
-
-    // Supervisor mode
-    static void sint_enable()  { ASM("csrsi sstatus, %0" : : "i"(SIE) : "cc"); }
-    static void sint_disable() { ASM("csrci sstatus, %0" : : "i"(SIE) : "cc"); }
-
-    static void sscratch(Reg r)   { ASM("csrw sscratch, %0" : : "r"(r) : "cc"); }
-    static Reg  sscratch() { Reg r; ASM("csrr %0, sscratch" :  "=r"(r) : : ); return r; }
-
-    static void sstatus(Reg r)   { ASM("csrw sstatus, %0" : : "r"(r) : "cc"); }
-    static Reg  sstatus() { Reg r; ASM("csrr %0, sstatus" :  "=r"(r) : : ); return r; }
-    static void sstatusc(Reg r)  { ASM("csrc sstatus, %0" : : "r"(r) : "cc"); }
-    static void sstatuss(Reg r)  { ASM("csrs sstatus, %0" : : "r"(r) : "cc"); }
-
-    static void sie(Reg r)   { ASM("csrw sie, %0" : : "r"(r) : "cc"); }
-    static void siec(Reg r)  { ASM("csrc sie, %0" : : "r"(r) : "cc"); }
-    static void sies(Reg r)  { ASM("csrs sie, %0" : : "r"(r) : "cc"); }
-    static Reg  sie() { Reg r; ASM("csrr %0, sie" :  "=r"(r) : : ); return r; }
-
-    static void sip(Reg r)   { ASM("csrw sip, %0" : : "r"(r) : "cc"); }
-    static void sipc(Reg r)  { ASM("csrc sip, %0" : : "r"(r) : "cc"); }
-    static void sips(Reg r)  { ASM("csrs sip, %0" : : "r"(r) : "cc"); }
-    static Reg  sip() { Reg r; ASM("csrr %0, sip" :  "=r"(r) : : ); return r; }
-
-    static Reg scause() { Reg r; ASM("csrr %0, scause" : "=r"(r) : : ); return r; }
-    static Reg stval()  { Reg r; ASM("csrr %0, stval" :  "=r"(r) : : ); return r; }
-
-    static void sepc(Reg r)   { ASM("csrw sepc, %0" : : "r"(r) : "cc"); }
-    static Reg  sepc() { Reg r; ASM("csrr %0, sepc" :  "=r"(r) : : ); return r; }
-
-    static void sret() { ASM("sret"); }
-
-    static void satp(Reg r) { ASM("csrw satp, %0" : : "r"(r) : "cc"); }
-    static Reg  satp() { Reg r; ASM("csrr %0, satp" :  "=r"(r) : : ); return r; }
-
-private:
-    template<typename Head, typename ... Tail>
-    static void init_stack_helper(Log_Addr sp, Head head, Tail ... tail) {
-        *static_cast<Head *>(sp) = head;
-        init_stack_helper(sp + sizeof(Head), tail ...);
-    }
-    static void init_stack_helper(Log_Addr sp) {}
-
-    static void init();
-
-private:
-    static unsigned int _cpu_clock;
-    static unsigned int _bus_clock;
-};
-
-inline void CPU::Context::push(bool interrupt)
-{
-    ASM("       addi     sp, sp, %0             \n" : : "i"(-sizeof(Context))); // adjust SP for the pushes below
-
-if(interrupt) {
-    ASM("       csrr     x3,    mepc            \n"
-        "       sd       x3,    0(sp)           \n");   // push MEPC as PC on interrupts
-} else {
-    ASM("       sw       x1,    0(sp)           \n");   // push RA as PC on context switches
-}
-
-    ASM("       csrr     x3,  mstatus           \n");
-
-    ASM("       sd       x3,    8(sp)           \n"     // push ST
-        "       sd       x1,   16(sp)           \n"     // push RA
-        "       sd       x5,   24(sp)           \n"     // push x5-x31
-        "       sd       x6,   32(sp)           \n"
-        "       sd       x7,   40(sp)           \n"
-        "       sd       x8,   48(sp)           \n"
-        "       sd       x9,   56(sp)           \n"
-        "       sd      x10,   64(sp)           \n"
-        "       sd      x11,   72(sp)           \n"
-        "       sd      x12,   80(sp)           \n"
-        "       sd      x13,   88(sp)           \n"
-        "       sd      x14,   96(sp)           \n"
-        "       sd      x15,  104(sp)           \n"
-        "       sd      x16,  112(sp)           \n"
-        "       sd      x17,  120(sp)           \n"
-        "       sd      x18,  128(sp)           \n"
-        "       sd      x19,  136(sp)           \n"
-        "       sd      x20,  144(sp)           \n"
-        "       sd      x21,  152(sp)           \n"
-        "       sd      x22,  160(sp)           \n"
-        "       sd      x23,  168(sp)           \n"
-        "       sd      x24,  176(sp)           \n"
-        "       sd      x25,  184(sp)           \n"
-        "       sd      x26,  192(sp)           \n"
-        "       sd      x27,  200(sp)           \n"
-        "       sd      x28,  208(sp)           \n"
-        "       sd      x29,  216(sp)           \n"
-        "       sd      x30,  224(sp)           \n"
-        "       sd      x31,  232(sp)           \n");
-}
-
-inline void CPU::Context::pop(bool interrupt)
-{
-    ASM("       ld       x3,    0(sp)           \n");   // pop PC into TMP
-if(interrupt) {
-    ASM("       add      x3, x3, a0             \n");   // a0 is set by exception handlers to adjust [M|S]EPC to point to the next instruction if needed
-}
-    ASM("       csrw     mepc, x3               \n");   // MEPC = PC
-
-    ASM("       ld       x3,    8(sp)           \n");   // pop ST into TMP
-if(!interrupt) {
-    ASM("       li       a0, 3 << 11            \n"     // use a0 as a second TMP, since it will be restored later
-        "       or       x3, x3, a0             \n");   // mstatus.MPP is automatically cleared on mret, so we reset it to MPP_M here
-}
-
-    ASM("       ld       x1,   16(sp)           \n"     // pop RA
-        "       ld       x5,   24(sp)           \n"     // pop x5-x31
-        "       ld       x6,   32(sp)           \n"
-        "       ld       x7,   40(sp)           \n"
-        "       ld       x8,   48(sp)           \n"
-        "       ld       x9,   56(sp)           \n"
-        "       ld      x10,   64(sp)           \n"
-        "       ld      x11,   72(sp)           \n"
-        "       ld      x12,   80(sp)           \n"
-        "       ld      x13,   88(sp)           \n"
-        "       ld      x14,   96(sp)           \n"
-        "       ld      x15,  104(sp)           \n"
-        "       ld      x16,  112(sp)           \n"
-        "       ld      x17,  120(sp)           \n"
-        "       ld      x18,  128(sp)           \n"
-        "       ld      x19,  136(sp)           \n"
-        "       ld      x20,  144(sp)           \n"
-        "       ld      x21,  152(sp)           \n"
-        "       ld      x22,  160(sp)           \n"
-        "       ld      x23,  168(sp)           \n"
-        "       ld      x24,  176(sp)           \n"
-        "       ld      x25,  184(sp)           \n"
-        "       ld      x26,  192(sp)           \n"
-        "       ld      x27,  200(sp)           \n"
-        "       ld      x28,  208(sp)           \n"
-        "       ld      x29,  216(sp)           \n"
-        "       ld      x30,  224(sp)           \n"
-        "       ld      x31,  232(sp)           \n"
-        "       addi    sp, sp, %0              \n" : : "i"(sizeof(Context))); // complete the pops above by adjusting SP
-
-    ASM("       csrw    mstatus, x3             \n");   // MSTATUS = ST
-}
-
-inline CPU::Reg64 htole64(CPU::Reg64 v) { return CPU::htole64(v); }
-inline CPU::Reg32 htole32(CPU::Reg32 v) { return CPU::htole32(v); }
-inline CPU::Reg16 htole16(CPU::Reg16 v) { return CPU::htole16(v); }
-inline CPU::Reg64 letoh64(CPU::Reg64 v) { return CPU::letoh64(v); }
-inline CPU::Reg32 letoh32(CPU::Reg32 v) { return CPU::letoh32(v); }
-inline CPU::Reg16 letoh16(CPU::Reg16 v) { return CPU::letoh16(v); }
-
-inline CPU::Reg64 htobe64(CPU::Reg64 v) { return CPU::htobe64(v); }
-inline CPU::Reg32 htobe32(CPU::Reg32 v) { return CPU::htobe32(v); }
-inline CPU::Reg16 htobe16(CPU::Reg16 v) { return CPU::htobe16(v); }
-inline CPU::Reg64 betoh64(CPU::Reg64 v) { return CPU::betoh64(v); }
-inline CPU::Reg32 betoh32(CPU::Reg32 v) { return CPU::betoh32(v); }
-inline CPU::Reg16 betoh16(CPU::Reg16 v) { return CPU::betoh16(v); }
-
-inline CPU::Reg32 htonl(CPU::Reg32 v)   { return CPU::htonl(v); }
-inline CPU::Reg16 htons(CPU::Reg16 v)   { return CPU::htons(v); }
-inline CPU::Reg32 ntohl(CPU::Reg32 v)   { return CPU::ntohl(v); }
-inline CPU::Reg16 ntohs(CPU::Reg16 v)   { return CPU::ntohs(v); }
-
-__END_SYS
-
-#endif
diff --git a/include/architecture/rv64/rv64_mmu.h b/include/architecture/rv64/rv64_mmu.h
deleted file mode 100644
index aca12f3..0000000
--- a/include/architecture/rv64/rv64_mmu.h
+++ /dev/null
@@ -1,17 +0,0 @@
-// EPOS RISC-V 64 MMU Mediator Declarations
-
-#ifndef __rv64_mmu_h
-#define __rv64_mmu_h
-
-#define __mmu_common_only__
-#include <architecture/mmu.h>
-#undef __mmu_common_only__
-#include <system/memory_map.h>
-
-__BEGIN_SYS
-
-class MMU: public No_MMU {};
-
-__END_SYS
-
-#endif
diff --git a/include/architecture/rv64/rv64_pmu.h b/include/architecture/rv64/rv64_pmu.h
deleted file mode 100644
index 03d8dd9..0000000
--- a/include/architecture/rv64/rv64_pmu.h
+++ /dev/null
@@ -1,502 +0,0 @@
-// EPOS RV64 PMU Mediator Declarations
-
-#ifndef __rv64_pmu_h
-#define __rv64_pmu_h
-
-#include <architecture/cpu.h>
-#define __pmu_common_only__
-#include <architecture/pmu.h>
-#undef __pmu_common_only__
-#define __rv32_pmu_common_only__
-#include <architecture/rv32/rv32_pmu.h>
-#undef __rv32_pmu_common_only__
-
-__BEGIN_SYS
-
-class RV64_PMU: public RV32_PMU
-{
-private:
-    typedef CPU::Reg Reg;
-
-public:
-    RV64_PMU() {}
-
-    static void config(Channel channel, const Event event, Flags flags = NONE) {
-        assert((channel < CHANNELS) && (event < EVENTS));
-
-        db<PMU>(TRC) << "PMU::config(c=" << channel << ",e=" << event << ",f=" << flags << ")" << endl;
-
-        if(((channel == 0) && (_events[event] != 0)) || ((channel == 1) && (_events[event] != 1)) || ((channel == 2) && (_events[event] != 2))) {
-            db<PMU>(WRN) << "PMU::config: channel " << channel << " is fixed in this architecture and cannot be reconfigured!" << endl;
-            return;
-        }
-
-        if((channel >= FIXED) && (_events[event] != UNSUPORTED_EVENT)) {
-            mhpmevent(_events[event], channel);
-            start(channel);
-        }
-    }
-
-    static void start(Channel channel) {
-        db<PMU>(TRC) << "PMU::start(c=" << channel << ")" << endl;
-        mcounteren(mcounteren() | 1 << channel);
-    }
-
-    static Count read(Channel channel) {
-        db<PMU>(TRC) << "PMU::read(c=" << channel << ")" << endl;
-        return mhpmcounter(channel);
-    }
-
-    static void write(Channel channel, Count count) {
-        db<PMU>(TRC) << "PMU::write(ch=" << channel << ",ct=" << count << ")" << endl;
-        mhpmcounter(channel, count);
-    }
-
-    static void stop(Channel channel) {
-        db<PMU>(TRC) << "PMU::stop(c=" << channel << ")" << endl;
-        if(channel < FIXED)
-            db<PMU>(WRN) << "PMU::stop(c=" << channel << ") : fixed channels cannot be stopped!" << endl;
-        mcounteren(mcounteren() & ~(1 << channel));
-    }
-
-    static void reset(Channel channel) {
-        db<PMU>(TRC) << "PMU::reset(c=" << channel << ")" << endl;
-        write(channel, 0);
-    }
-
-    static void init() {}
-
-private:
-    static Reg mcounteren(){ Reg reg; ASM("csrr %0, mcounteren" : "=r"(reg) :); return reg;}
-    static void mcounteren(Reg reg){    ASM("csrw mcounteren, %0" : : "r"(reg));}
-
-    static Reg mhpmevent(Channel channel) {
-        Reg reg;
-        switch(channel)
-        {
-        case 3:
-            ASM("csrr %0, mhpmevent3" : : "r"(reg));
-            break;
-        case 4:
-            ASM("csrr %0, mhpmevent4" : : "r"(reg));
-            break;
-        case 5:
-            ASM("csrr %0, mhpmevent5" : : "r"(reg));
-            break;
-        case 6:
-            ASM("csrr %0, mhpmevent6" : : "r"(reg));
-            break;
-        case 7:
-            ASM("csrr %0, mhpmevent7" : : "r"(reg));
-            break;
-        case 8:
-            ASM("csrr %0, mhpmevent8" : : "r"(reg));
-            break;
-        case 9:
-            ASM("csrr %0, mhpmevent9" : : "r"(reg));
-            break;
-        case 10:
-            ASM("csrr %0, mhpmevent10" : : "r"(reg));
-            break;
-        case 11:
-            ASM("csrr %0, mhpmevent11" : : "r"(reg));
-            break;
-        case 12:
-            ASM("csrr %0, mhpmevent12" : : "r"(reg));
-            break;
-        case 13:
-            ASM("csrr %0, mhpmevent13" : : "r"(reg));
-            break;
-        case 14:
-            ASM("csrr %0, mhpmevent14" : : "r"(reg));
-            break;
-        case 15:
-            ASM("csrr %0, mhpmevent15" : : "r"(reg));
-            break;
-        case 16:
-            ASM("csrr %0, mhpmevent16" : : "r"(reg));
-            break;
-        case 17:
-            ASM("csrr %0, mhpmevent17" : : "r"(reg));
-            break;
-        case 18:
-            ASM("csrr %0, mhpmevent18" : : "r"(reg));
-            break;
-        case 19:
-            ASM("csrr %0, mhpmevent19" : : "r"(reg));
-            break;
-        case 20:
-            ASM("csrr %0, mhpmevent20" : : "r"(reg));
-            break;
-        case 21:
-            ASM("csrr %0, mhpmevent21" : : "r"(reg));
-            break;
-        case 22:
-            ASM("csrr %0, mhpmevent22" : : "r"(reg));
-            break;
-        case 23:
-            ASM("csrr %0, mhpmevent23" : : "r"(reg));
-            break;
-        case 24:
-            ASM("csrr %0, mhpmevent24" : : "r"(reg));
-            break;
-        case 25:
-            ASM("csrr %0, mhpmevent25" : : "r"(reg));
-            break;
-        case 26:
-            ASM("csrr %0, mhpmevent26" : : "r"(reg));
-            break;
-        case 27:
-            ASM("csrr %0, mhpmevent27" : : "r"(reg));
-            break;
-        case 28:
-            ASM("csrr %0, mhpmevent28" : : "r"(reg));
-            break;
-        case 29:
-            ASM("csrr %0, mhpmevent29" : : "r"(reg));
-            break;
-        case 30:
-            ASM("csrr %0, mhpmevent30" : : "r"(reg));
-            break;
-        case 31:
-            ASM("csrr %0, mhpmevent31" : : "r"(reg));
-            break;
-        }
-
-        return reg;
-    }
-
-    static void mhpmevent(Reg reg, Channel channel) {
-        switch (channel)
-        {
-        case 3:
-            ASM("csrw mhpmevent3,  %0" : : "r"(reg));
-            break;
-        case 4:
-            ASM("csrw mhpmevent4,  %0" : : "r"(reg));
-            break;
-        case 5:
-            ASM("csrw mhpmevent5,  %0" : : "r"(reg));
-            break;
-        case 6:
-            ASM("csrw mhpmevent6,  %0" : : "r"(reg));
-            break;
-        case 7:
-            ASM("csrw mhpmevent7,  %0" : : "r"(reg));
-            break;
-        case 8:
-            ASM("csrw mhpmevent8,  %0" : : "r"(reg));
-            break;
-        case 9:
-            ASM("csrw mhpmevent9,  %0" : : "r"(reg));
-            break;
-        case 10:
-            ASM("csrw mhpmevent10, %0" : : "r"(reg));
-            break;
-        case 11:
-            ASM("csrw mhpmevent11, %0" : : "r"(reg));
-            break;
-        case 12:
-            ASM("csrw mhpmevent12, %0" : : "r"(reg));
-            break;
-        case 13:
-            ASM("csrw mhpmevent13, %0" : : "r"(reg));
-            break;
-        case 14:
-            ASM("csrw mhpmevent14, %0" : : "r"(reg));
-            break;
-        case 15:
-            ASM("csrw mhpmevent15, %0" : : "r"(reg));
-            break;
-        case 16:
-            ASM("csrw mhpmevent16, %0" : : "r"(reg));
-            break;
-        case 17:
-            ASM("csrw mhpmevent17, %0" : : "r"(reg));
-            break;
-        case 18:
-            ASM("csrw mhpmevent18, %0" : : "r"(reg));
-            break;
-        case 19:
-            ASM("csrw mhpmevent19, %0" : : "r"(reg));
-            break;
-        case 20:
-            ASM("csrw mhpmevent20, %0" : : "r"(reg));
-            break;
-        case 21:
-            ASM("csrw mhpmevent21, %0" : : "r"(reg));
-            break;
-        case 22:
-            ASM("csrw mhpmevent22, %0" : : "r"(reg));
-            break;
-        case 23:
-            ASM("csrw mhpmevent23, %0" : : "r"(reg));
-            break;
-        case 24:
-            ASM("csrw mhpmevent24, %0" : : "r"(reg));
-            break;
-        case 25:
-            ASM("csrw mhpmevent25, %0" : : "r"(reg));
-            break;
-        case 26:
-            ASM("csrw mhpmevent26, %0" : : "r"(reg));
-            break;
-        case 27:
-            ASM("csrw mhpmevent27, %0" : : "r"(reg));
-            break;
-        case 28:
-            ASM("csrw mhpmevent28, %0" : : "r"(reg));
-            break;
-        case 29:
-            ASM("csrw mhpmevent29, %0" : : "r"(reg));
-            break;
-        case 30:
-            ASM("csrw mhpmevent30, %0" : : "r"(reg));
-            break;
-        case 31:
-            ASM("csrw mhpmevent31, %0" : : "r"(reg));
-            break;
-        }
-    }
-
-    static Count mhpmcounter(Reg counter) {
-        assert(counter < COUNTERS);
-
-        Count reg = 0;
-
-        switch(counter)
-        {
-        case 0:
-            ASM("rdcycle  %0" : "=r"(reg) : );
-            break;
-#ifndef __sifive_u__
-        case 1:
-            ASM("rdtime  %0" : "=r"(reg) : );
-            break;
-#endif
-        case 2:
-            ASM("rdinstret  %0" : "=r"(reg) : );
-            break;
-        case 3:
-            ASM("csrr %0, mhpmcounter3"  : "=r"(reg) : );
-            break;
-        case 4:
-            ASM("csrr %0, mhpmcounter4"  : "=r"(reg) : );
-            break;
-        case 5:
-            ASM("csrr %0, mhpmcounter5"  : "=r"(reg) : );
-            break;
-        case 6:
-            ASM("csrr %0, mhpmcounter6"  : "=r"(reg) : );
-            break;
-        case 7:
-            ASM("csrr %0, mhpmcounter7"  : "=r"(reg) : );
-            break;
-        case 8:
-            ASM("csrr %0, mhpmcounter8"  : "=r"(reg) : );
-            break;
-        case 9:
-            ASM("csrr %0, mhpmcounter9"  : "=r"(reg) : );
-            break;
-        case 10:
-            ASM("csrr %0, mhpmcounter10"  : "=r"(reg) : );
-            break;
-        case 11:
-            ASM("csrr %0, mhpmcounter11"  : "=r"(reg) : );
-            break;
-        case 12:
-            ASM("csrr %0, mhpmcounter12"  : "=r"(reg) : );
-            break;
-        case 13:
-            ASM("csrr %0, mhpmcounter13"  : "=r"(reg) : );
-            break;
-        case 14:
-            ASM("csrr %0, mhpmcounter14"  : "=r"(reg) : );
-            break;
-        case 15:
-            ASM("csrr %0, mhpmcounter15"  : "=r"(reg) : );
-            break;
-        case 16:
-            ASM("csrr %0, mhpmcounter16"  : "=r"(reg) : );
-            break;
-        case 17:
-            ASM("csrr %0, mhpmcounter17"  : "=r"(reg) : );
-            break;
-        case 18:
-            ASM("csrr %0, mhpmcounter18"  : "=r"(reg) : );
-            break;
-        case 19:
-            ASM("csrr %0, mhpmcounter19"  : "=r"(reg) : );
-            break;
-        case 20:
-            ASM("csrr %0, mhpmcounter20"  : "=r"(reg) : );
-            break;
-        case 21:
-            ASM("csrr %0, mhpmcounter21"  : "=r"(reg) : );
-            break;
-        case 22:
-            ASM("csrr %0, mhpmcounter22"  : "=r"(reg) : );
-            break;
-        case 23:
-            ASM("csrr %0, mhpmcounter23"  : "=r"(reg) : );
-            break;
-        case 24:
-            ASM("csrr %0, mhpmcounter24"  : "=r"(reg) : );
-            break;
-        case 25:
-            ASM("csrr %0, mhpmcounter25"  : "=r"(reg) : );
-            break;
-        case 26:
-            ASM("csrr %0, mhpmcounter26"  : "=r"(reg) : );
-            break;
-        case 27:
-            ASM("csrr %0, mhpmcounter27"  : "=r"(reg) : );
-            break;
-        case 28:
-            ASM("csrr %0, mhpmcounter28"  : "=r"(reg) : );
-            break;
-        case 29:
-            ASM("csrr %0, mhpmcounter29"  : "=r"(reg) : );
-            break;
-        case 30:
-            ASM("csrr %0, mhpmcounter30"  : "=r"(reg) : );
-            break;
-        case 31:
-            ASM("csrr %0, mhpmcounter31"  : "=r"(reg) : );
-            break;
-        }
-        return reg;
-    }
-
-    static void mhpmcounter(Reg counter, Count reg) {
-        assert(counter < COUNTERS);
-
-        switch(counter)
-        {
-        case 3:
-            ASM("csrw mhpmcounter3,  %0" : : "r"(reg));
-            break;
-        case 4:
-            ASM("csrw mhpmcounter4,  %0" : : "r"(reg));
-            break;
-        case 5:
-            ASM("csrw mhpmcounter5,  %0" : : "r"(reg));
-            break;
-        case 6:
-            ASM("csrw mhpmcounter6,  %0" : : "r"(reg));
-            break;
-        case 7:
-            ASM("csrw mhpmcounter7,  %0" : : "r"(reg));
-            break;
-        case 8:
-            ASM("csrw mhpmcounter8,  %0" : : "r"(reg));
-            break;
-        case 9:
-            ASM("csrw mhpmcounter9,  %0" : : "r"(reg));
-            break;
-        case 10:
-            ASM("csrw mhpmcounter10,  %0" : : "r"(reg));
-            break;
-        case 11:
-            ASM("csrw mhpmcounter11,  %0" : : "r"(reg));
-            break;
-        case 12:
-            ASM("csrw mhpmcounter12,  %0" : : "r"(reg));
-            break;
-        case 13:
-            ASM("csrw mhpmcounter13,  %0" : : "r"(reg));
-            break;
-        case 14:
-            ASM("csrw mhpmcounter14,  %0" : : "r"(reg));
-            break;
-        case 15:
-            ASM("csrw mhpmcounter15,  %0" : : "r"(reg));
-            break;
-        case 16:
-            ASM("csrw mhpmcounter16,  %0" : : "r"(reg));
-            break;
-        case 17:
-            ASM("csrw mhpmcounter17,  %0" : : "r"(reg));
-            break;
-        case 18:
-            ASM("csrw mhpmcounter18,  %0" : : "r"(reg));
-            break;
-        case 19:
-            ASM("csrw mhpmcounter19,  %0" : : "r"(reg));
-            break;
-        case 20:
-            ASM("csrw mhpmcounter20,  %0" : : "r"(reg));
-            break;
-        case 21:
-            ASM("csrw mhpmcounter21,  %0" : : "r"(reg));
-            break;
-        case 22:
-            ASM("csrw mhpmcounter22,  %0" : : "r"(reg));
-            break;
-        case 23:
-            ASM("csrw mhpmcounter23,  %0" : : "r"(reg));
-            break;
-        case 24:
-            ASM("csrw mhpmcounter24,  %0" : : "r"(reg));
-            break;
-        case 25:
-            ASM("csrw mhpmcounter25,  %0" : : "r"(reg));
-            break;
-        case 26:
-            ASM("csrw mhpmcounter26,  %0" : : "r"(reg));
-            break;
-        case 27:
-            ASM("csrw mhpmcounter27,  %0" : : "r"(reg));
-            break;
-        case 28:
-            ASM("csrw mhpmcounter28,  %0" : : "r"(reg));
-            break;
-        case 29:
-            ASM("csrw mhpmcounter29,  %0" : : "r"(reg));
-            break;
-        case 30:
-            ASM("csrw mhpmcounter30,  %0" : : "r"(reg));
-            break;
-        case 31:
-            ASM("csrw mhpmcounter31,  %0" : : "r"(reg));
-            break;
-        default:
-            db<PMU>(WRN) << "PMU::mhpmcounter(c=" << counter << "): counter is read-only!" << endl;
-        }
-    }
-};
-
-
-class PMU: public RV64_PMU
-{
-    friend class CPU;
-
-private:
-    typedef RV64_PMU Engine;
-
-public:
-    using Engine::CHANNELS;
-    using Engine::FIXED;
-    using Engine::EVENTS;
-
-    using Engine::Event;
-    using Engine::Count;
-    using Engine::Channel;
-
-public:
-    PMU() {}
-
-    using Engine::config;
-    using Engine::read;
-    using Engine::write;
-    using Engine::start;
-    using Engine::stop;
-    using Engine::reset;
-
-private:
-    static void init() { Engine::init(); }
-};
-
-__END_SYS
-
-#endif
diff --git a/include/architecture/rv64/rv64_traits.h b/include/architecture/rv64/rv64_traits.h
deleted file mode 100644
index 251375f..0000000
--- a/include/architecture/rv64/rv64_traits.h
+++ /dev/null
@@ -1,43 +0,0 @@
-// EPOS RISC-V 64 Architecture Metainfo
-
-#ifndef __rv64_traits_h
-#define __rv64_traits_h
-
-#include <system/config.h>
-
-__BEGIN_SYS
-
-template<> struct Traits<CPU>: public Traits<Build>
-{
-    enum {LITTLE, BIG};
-    static const unsigned int ENDIANESS         = LITTLE;
-    static const unsigned int WORD_SIZE         = 64;
-    static const unsigned int CLOCK             = 50000000;
-    static const bool unaligned_memory_access   = false;
-};
-
-template<> struct Traits<MMU>: public Traits<Build>
-{
-    static const bool colorful = false;
-    static const unsigned int COLORS = 1;
-};
-
-template<> struct Traits<FPU>: public Traits<Build>
-{
-    static const bool enabled = false;
-    static const bool user_save = true;
-};
-
-template<> struct Traits<TSC>: public Traits<Build>
-{
-    static const bool enabled = true;
-};
-
-template<> struct Traits<PMU>: public Traits<Build>
-{
-    static const bool enabled = true;
-};
-
-__END_SYS
-
-#endif
diff --git a/include/architecture/rv64/rv64_tsc.h b/include/architecture/rv64/rv64_tsc.h
deleted file mode 100644
index 5ff20d0..0000000
--- a/include/architecture/rv64/rv64_tsc.h
+++ /dev/null
@@ -1,48 +0,0 @@
-// EPOS RISC-V 64 Time-Stamp Counter Mediator Declarations
-
-#ifndef __rv64_tsc_h
-#define __rv64_tsc_h
-
-#include <architecture/cpu.h>
-#include <architecture/tsc.h>
-#include <system/memory_map.h>
-
-__BEGIN_SYS
-
-class TSC: private TSC_Common
-{
-    friend class CPU;
-    friend class IC;
-
-private:
-    static const unsigned int CLOCK = Traits<Timer>::CLOCK;
-    static const unsigned int ACCURACY = 40000; // this is actually unknown at the moment
-
-    // Registers offsets from CLINT_BASE
-    enum {               // Description
-        MTIME  = 0xbff8, // Counter (lower 32 bits)
-        MTIMEH = 0xbffc  // Counter (upper 32 bits)
-    };
-
-public:
-    using TSC_Common::Time_Stamp;
-
-    static const unsigned int FREQUENCY = CLOCK;
-
-public:
-    TSC() {}
-
-    static Hertz frequency() { return CLOCK; }
-    static PPB accuracy() { return ACCURACY; }
-
-    static Time_Stamp time_stamp() { return (CPU::Reg64(reg(MTIMEH)) << 32) | reg(MTIME); }
-
-private:
-    static void init() {}
-
-    static volatile CPU::Reg32 & reg(unsigned int o) { return reinterpret_cast<volatile CPU::Reg32 *>(Memory_Map::CLINT_BASE)[o / sizeof(CPU::Reg32)]; }
-};
-
-__END_SYS
-
-#endif
diff --git a/include/machine/cortex/cortex_timer.h b/include/machine/cortex/cortex_timer.h
index fca6518..145e5b4 100644
--- a/include/machine/cortex/cortex_timer.h
+++ b/include/machine/cortex/cortex_timer.h
@@ -15,18 +15,17 @@ __BEGIN_SYS
 class Timer: public System_Timer_Engine
 {
     friend Machine;             // for init()
-    friend class Init_System;   // for init()
     friend IC;                  // for eoi()
 
 protected:
-    typedef System_Timer_Engine Engine;
-    typedef IC_Common::Interrupt_Id Interrupt_Id;
-
     static const unsigned int CHANNELS = 2;
     static const unsigned int FREQUENCY = Traits<Timer>::FREQUENCY;
 
+    typedef System_Timer_Engine Engine;
+    typedef IC_Common::Interrupt_Id Interrupt_Id;
+
 protected:
-    Timer(Channel channel, Hertz frequency, const Handler & handler, bool retrigger = true)
+    Timer(Channel channel, const Hertz & frequency, const Handler & handler, bool retrigger = true)
     : _channel(channel), _initial(FREQUENCY / frequency), _retrigger(retrigger), _handler(handler) {
         db<Timer>(TRC) << "Timer(f=" << frequency << ",h=" << reinterpret_cast<void*>(handler) << ",ch=" << channel << ") => {count=" << _initial << "}" << endl;
 
@@ -47,15 +46,6 @@ public:
 
     Tick read() { return _current; }
 
-    int restart() {
-        db<Timer>(TRC) << "Timer::restart() => {f=" << frequency() << ",h=" << reinterpret_cast<void *>(_handler) << ",count=" << _current << "}" << endl;
-
-        int percentage = _current * 100 / _initial;
-        _current= _initial;
-
-        return percentage;
-    }
-
     static void reset() { db<Timer>(TRC) << "Timer::reset()" << endl; Engine::reset(); }
     static void enable() { db<Timer>(TRC) << "Timer::enable()" << endl; Engine::enable(); }
     static void disable() { db<Timer>(TRC) << "Timer::disable()" << endl; Engine::disable(); }
@@ -88,11 +78,23 @@ class Scheduler_Timer: public Timer
 {
 public:
     Scheduler_Timer(Microsecond quantum, const Handler & handler): Timer(SCHEDULER, 1000000 / quantum, handler) {}
+
+    int restart() {
+        db<Timer>(TRC) << "Timer::restart() => {f=" << frequency() << ",h=" << reinterpret_cast<void *>(_handler) << ",count=" << _current << "}" << endl;
+
+        int percentage = _current * 100 / _initial;
+        _current= _initial;
+
+        return percentage;
+    }
 };
 
 // Timer used by Alarm
 class Alarm_Timer: public Timer
 {
+public:
+    static const unsigned int FREQUENCY = Timer::FREQUENCY;
+
 public:
     Alarm_Timer(const Handler & handler): Timer(ALARM, FREQUENCY, handler) {}
 };
diff --git a/include/machine/cortex/realview_pbx/realview_pbx_traits.h b/include/machine/cortex/realview_pbx/realview_pbx_traits.h
index ae02ecb..8dc608c 100644
--- a/include/machine/cortex/realview_pbx/realview_pbx_traits.h
+++ b/include/machine/cortex/realview_pbx/realview_pbx_traits.h
@@ -18,10 +18,10 @@ template<> struct Traits<Machine_Common>: public Traits<Build>
 
 template<> struct Traits<Machine>: public Traits<Machine_Common>
 {
-    static const unsigned int NOT_USED          = 0xffffffff;
-
     static const bool cpus_use_local_timer      = true;
 
+    static const unsigned int NOT_USED          = 0xffffffff;
+
     // Physical Memory
     static const unsigned int RAM_BASE          = 0x00000000;
     static const unsigned int RAM_TOP           = 0x07ffffff;   // 128 MB
diff --git a/include/machine/pc/pc_ic.h b/include/machine/pc/pc_ic.h
index e320383..4a13632 100644
--- a/include/machine/pc/pc_ic.h
+++ b/include/machine/pc/pc_ic.h
@@ -544,6 +544,9 @@ private:
     static Interrupt_Handler _int_vector[INTS];
 };
 
+// Core id in IA32 might be handled by the APIC
+inline volatile unsigned int CPU::id() { return 0; }
+
 __END_SYS
 
 #endif
diff --git a/include/machine/pc/pc_timer.h b/include/machine/pc/pc_timer.h
index 1d62840..81b8ca8 100644
--- a/include/machine/pc/pc_timer.h
+++ b/include/machine/pc/pc_timer.h
@@ -285,7 +285,7 @@ public:
 
     void handler(const Handler & handler) { _handler = handler; }
 
-private:
+ private:
     static void int_handler(Interrupt_Id i);
 
     static void init();
@@ -305,7 +305,7 @@ protected:
 class Scheduler_Timer: public Timer
 {
 public:
-    Scheduler_Timer(Microsecond quantum, const Handler & handler): Timer(SCHEDULER, 1000000 / quantum, handler) {}
+    Scheduler_Timer(const Microsecond & quantum, const Handler & handler): Timer(SCHEDULER, 1000000 / quantum, handler) {}
 };
 
 // Timer used by Alarm
diff --git a/include/machine/riscv/riscv_ic.h b/include/machine/riscv/riscv_ic.h
index 68ee0e8..88d819c 100644
--- a/include/machine/riscv/riscv_ic.h
+++ b/include/machine/riscv/riscv_ic.h
@@ -146,6 +146,12 @@ public:
     static int irq2int(int i) { return i + EXCS; }
     static int int2irq(int i) { return i - EXCS; }
 
+    static void ipi(unsigned int cpu, Interrupt_Id i) {
+        db<IC>(TRC) << "IC::ipi(cpu=" << cpu << ",int=" << i << ")" << endl;
+        assert(i < INTS);
+        reg(MSIP + cpu * MSIP_CORE_OFFSET) = 1;
+    }
+
 private:
     static void dispatch();
 
diff --git a/include/machine/riscv/riscv_machine.h b/include/machine/riscv/riscv_machine.h
index 97327ce..199d0c2 100644
--- a/include/machine/riscv/riscv_machine.h
+++ b/include/machine/riscv/riscv_machine.h
@@ -32,7 +32,7 @@ public:
     static const UUID & uuid() { return System::info()->bm.uuid; }
 
 private:
-    static void pre_init(System_Info * si) {}
+    static void pre_init(System_Info * si);
     static void init();
 };
 
diff --git a/include/machine/riscv/riscv_timer.h b/include/machine/riscv/riscv_timer.h
index e0d4e3c..91586b3 100644
--- a/include/machine/riscv/riscv_timer.h
+++ b/include/machine/riscv/riscv_timer.h
@@ -19,11 +19,11 @@ class Timer: private Timer_Common, private CLINT
     friend class Init_System;
 
 protected:
-    typedef IC_Common::Interrupt_Id Interrupt_Id;
-
     static const unsigned int CHANNELS = 2;
     static const unsigned int FREQUENCY = Traits<Timer>::FREQUENCY;
 
+    typedef IC_Common::Interrupt_Id Interrupt_Id;
+
 public:
     using Timer_Common::Tick;
     using Timer_Common::Handler;
@@ -58,16 +58,8 @@ public:
 
     Tick read() { return _current; }
 
-    int restart() {
-        db<Timer>(TRC) << "Timer::restart() => {f=" << frequency() << ",h=" << reinterpret_cast<void *>(_handler) << ",count=" << _current << "}" << endl;
-
-        int percentage = _current * 100 / _initial;
-        _current = _initial;
-
-        return percentage;
-    }
-
     static void reset() { config(FREQUENCY); }
+
     static void enable() {}
     static void disable() {}
 
@@ -102,11 +94,23 @@ class Scheduler_Timer: public Timer
 {
 public:
     Scheduler_Timer(const Microsecond & quantum, const Handler & handler): Timer(SCHEDULER, 1000000 / quantum, handler) {}
+
+    int restart() {
+        db<Timer>(TRC) << "Timer::restart() => {f=" << frequency() << ",h=" << reinterpret_cast<void *>(_handler) << ",count=" << _current << "}" << endl;
+
+        int percentage = _current * 100 / _initial;
+        _current = _initial;
+
+        return percentage;
+    }
 };
 
 // Timer used by Alarm
 class Alarm_Timer: public Timer
 {
+public:
+    static const unsigned int FREQUENCY = Timer::FREQUENCY;
+
 public:
     Alarm_Timer(const Handler & handler): Timer(ALARM, FREQUENCY, handler) {}
 };
diff --git a/include/machine/riscv/sifive_e/sifive_e_traits.h b/include/machine/riscv/sifive_e/sifive_e_traits.h
index 7e10b23..a840708 100644
--- a/include/machine/riscv/sifive_e/sifive_e_traits.h
+++ b/include/machine/riscv/sifive_e/sifive_e_traits.h
@@ -45,9 +45,9 @@ public:
     static const unsigned int SYS               = 0xff800000;                           // 4 GB - 8 MB
 
     // Default Sizes and Quantities
-    static const unsigned int MAX_THREADS       = 7;
-    static const unsigned int STACK_SIZE        = 640;
-    static const unsigned int HEAP_SIZE         = 512;
+    static const unsigned int MAX_THREADS       = 8;
+    static const unsigned int STACK_SIZE        = 512;
+    static const unsigned int HEAP_SIZE         = 1024;
 };
 
 template <> struct Traits<IC>: public Traits<Machine_Common>
@@ -65,14 +65,16 @@ template <> struct Traits<Timer>: public Traits<Machine_Common>
     // Meaningful values for the timer frequency range from 100 to 10000 Hz. The
     // choice must respect the scheduler time-slice, i. e., it must be higher
     // than the scheduler invocation frequency.
-    static const int FREQUENCY = 1000; // Hz
+    static const int FREQUENCY = 10; // Hz
 };
 
 template <> struct Traits<UART>: public Traits<Machine_Common>
 {
     static const unsigned int UNITS = 2;
 
-    static const unsigned int CLOCK = 22729000;
+    static const unsigned int REFERENCE_CLOCK = 22729000;
+    static const unsigned int CLOCK_DIVISOR = 16;
+    static const unsigned int CLOCK = REFERENCE_CLOCK/CLOCK_DIVISOR;
 
     static const unsigned int DEF_UNIT = 1;
     static const unsigned int DEF_BAUD_RATE = 115200;
diff --git a/include/machine/riscv/sifive_u/sifive_u_memory_map.h b/include/machine/riscv/sifive_u/sifive_u_memory_map.h
index e02d7bf..f9a5fbd 100644
--- a/include/machine/riscv/sifive_u/sifive_u_memory_map.h
+++ b/include/machine/riscv/sifive_u/sifive_u_memory_map.h
@@ -21,7 +21,8 @@ public:
         RAM_TOP         = Traits<Machine>::RAM_TOP,
         MIO_BASE        = Traits<Machine>::MIO_BASE,
         MIO_TOP         = Traits<Machine>::MIO_TOP,
-        BOOT_STACK      = RAM_TOP + 1 - Traits<Machine>::STACK_SIZE, // will be used as the stack's base, not the stack pointer
+        INT_M2S         = RAM_TOP + 1 - 4096,   // the last page is used by the _int_m2s() interrupt forwarder installed by SETUP
+        BOOT_STACK      = INT_M2S - Traits<Machine>::STACK_SIZE, // will be used as the stack's base, not the stack pointer
         FREE_BASE       = RAM_BASE,
         FREE_TOP        = BOOT_STACK,
 
diff --git a/include/machine/riscv/sifive_u/sifive_u_traits.h b/include/machine/riscv/sifive_u/sifive_u_traits.h
index 80c52a9..74e1200 100644
--- a/include/machine/riscv/sifive_u/sifive_u_traits.h
+++ b/include/machine/riscv/sifive_u/sifive_u_traits.h
@@ -63,7 +63,7 @@ template <> struct Traits<Timer>: public Traits<Machine_Common>
     // Meaningful values for the timer frequency range from 100 to 10000 Hz. The
     // choice must respect the scheduler time-slice, i. e., it must be higher
     // than the scheduler invocation frequency.
-    static const int FREQUENCY = 1000; // Hz
+    static const int FREQUENCY = 10; // Hz
 };
 
 template <> struct Traits<UART>: public Traits<Machine_Common>
@@ -91,7 +91,7 @@ template<> struct Traits<Serial_Display>: public Traits<Machine_Common>
 
 template<> struct Traits<Scratchpad>: public Traits<Machine_Common>
 {
-    static const bool enabled = false;
+    static const bool enabled = true;
 };
 
 __END_SYS
diff --git a/include/machine/timer.h b/include/machine/timer.h
index 02be9dc..7c323d7 100644
--- a/include/machine/timer.h
+++ b/include/machine/timer.h
@@ -21,7 +21,7 @@ public:
         USER5
     };
 
-    typedef long Tick;
+    typedef int Tick;
     typedef IC_Common::Interrupt_Handler Handler;
 
 protected:
diff --git a/include/system/traits.h b/include/system/traits.h
index a430f7a..a9989aa 100644
--- a/include/system/traits.h
+++ b/include/system/traits.h
@@ -165,286 +165,8 @@ template<typename Component> class Authenticated;
 template<typename Component> class Shared;
 template<typename Component> class Remote;
 
-// Monitor events (Transducers)
-struct Transducer_Event { enum {
-    CPU_TEMPERATURE,
-    CPU_VOLTAGE,
-}; };
-
-
-// Monitor events (System)
- struct System_Event { enum {
-     ELAPSED_TIME,
-     DEADLINE_MISSES,
-     CPU_EXECUTION_TIME,
-     THREAD_EXECUTION_TIME,
-     RUNNING_THREAD,
- }; };
-
- // Monitor events (PMU)
- struct PMU_Event { enum {
-     CPU_CYCLES,
-     UNHALTED_CYCLES,
-
-     INSTRUCTIONS_RETIRED,
-     LOAD_INSTRUCTIONS_RETIRED,                      INTEGER_LOAD_INSTRUCTIONS_RETIRED = LOAD_INSTRUCTIONS_RETIRED,
-     STORE_INSTRUCTIONS_RETIRED,                     INTEGER_STORE_INSTRUCTIONS_RETIRED = STORE_INSTRUCTIONS_RETIRED,
-     INTEGER_ARITHMETIC_INSTRUCTIONS_RETIRED,
-     INTEGER_MULTIPLICATION_INSTRUCTIONS_RETIRED,
-     INTEGER_DIVISION_INSTRUCTIONS_RETIRED,
-     FPU_INSTRUCTIONS_RETIRED,
-     SIMD_INSTRUCTIONS_RETIRED,
-     ATOMIC_MEMEMORY_INSTRUCTIONS_RETIRED,
-
-     BRANCHES,
-     IMIDIATE_BRANCHES,
-     CONDITIONAL_BRANCHES,
-     BRANCH_MISPREDICTIONS,
-     BRANCH_DIRECTION_MISPREDICTIONS,
-     CONDITIONAL_BRANCH_MISPREDICTIONS,
-
-     EXCEPTIONS,
-     INTERRUPTS,
-
-     L1_CACHE_HITS,
-     L1_CACHE_MISSES,
-     L1_DATA_CACHE_MISSES,
-     L1_DATA_CACHE_WRITEBACKS,
-     L1_INSTRUCTION_CACHE_MISSES,                    INSTRUCTION_CACHE_MISSES = L1_INSTRUCTION_CACHE_MISSES,
-     L2_CACHE_HITS,
-     L2_CACHE_MISSES,
-     L2_DATA_CACHE_MISSES,
-     L2_DATA_CACHE_WRITEBACKS,
-     L3_CACHE_HITS,
-     L3_CACHE_MISSES,                                LAST_LEVEL_CACHE_HITS = L3_CACHE_HITS, LAST_LEVEL_CACHE_MISSES = L3_CACHE_MISSES, CACHE_MISSES = LAST_LEVEL_CACHE_MISSES, MEMORY_ACCESSES = LAST_LEVEL_CACHE_MISSES, DATA_MEMORY_ACCESSES = LAST_LEVEL_CACHE_MISSES,
-
-     INSTRUCTION_MEMORY_ACCESSES,
-     UNCACHED_MEMORY_ACCESSES,
-     UNALIGNED_MEMORY_ACCESSES,
-
-     BUS_CYCLES,
-     BUS_ACCESSES,
-     TLB_MISSES,
-     DATA_TLB_MISSES = TLB_MISSES,                   MMU_MISSES = TLB_MISSES,
-     INSTRUCTION_TLB_MISSES,
-     MEMORY_ERRORS,
-
-     STALL_CYCLES,
-     STALL_CYCLES_CACHE,                             STALL_CYCLES_INSTRUCTION_CACHE = STALL_CYCLES_CACHE,
-     STALL_CYCLES_DATA_CACHE,
-     STALL_CYCLES_TLB,
-     STALL_CYCLES_MEMORY,
-     PIPELINE_SERIALIZATIONS,    // ISB
-     BUS_SERIALIZATION,          // DSB = 44
-
-#if defined(__ia32__) || defined(__riscv__) || defined(__cortex_a__)
-     ARCHITECTURE_DEPENDENT_EVENT45,
-     ARCHITECTURE_DEPENDENT_EVENT46,
-     ARCHITECTURE_DEPENDENT_EVENT47,
-     ARCHITECTURE_DEPENDENT_EVENT48,
-     ARCHITECTURE_DEPENDENT_EVENT49,
-     ARCHITECTURE_DEPENDENT_EVENT50,
-     ARCHITECTURE_DEPENDENT_EVENT51,
-     ARCHITECTURE_DEPENDENT_EVENT52,
-     ARCHITECTURE_DEPENDENT_EVENT53,
-     ARCHITECTURE_DEPENDENT_EVENT54,
-     ARCHITECTURE_DEPENDENT_EVENT55,
-#endif
-#if defined(__ia32__) || defined(__cortex_a__)
-     ARCHITECTURE_DEPENDENT_EVENT56,
-     ARCHITECTURE_DEPENDENT_EVENT57,
-     ARCHITECTURE_DEPENDENT_EVENT58,
-     ARCHITECTURE_DEPENDENT_EVENT59,
-     ARCHITECTURE_DEPENDENT_EVENT60,
-     ARCHITECTURE_DEPENDENT_EVENT61,
-     ARCHITECTURE_DEPENDENT_EVENT62,
-     ARCHITECTURE_DEPENDENT_EVENT63,
-     ARCHITECTURE_DEPENDENT_EVENT64,
-     ARCHITECTURE_DEPENDENT_EVENT65,
-     ARCHITECTURE_DEPENDENT_EVENT66,
-     ARCHITECTURE_DEPENDENT_EVENT67,
-     ARCHITECTURE_DEPENDENT_EVENT68,
-     ARCHITECTURE_DEPENDENT_EVENT69,
-#endif
-#if defined(__ia32__) || defined(__cortex_a9__)
-     ARCHITECTURE_DEPENDENT_EVENT70,
-     ARCHITECTURE_DEPENDENT_EVENT71,
-     ARCHITECTURE_DEPENDENT_EVENT72,
-     ARCHITECTURE_DEPENDENT_EVENT73,
-     ARCHITECTURE_DEPENDENT_EVENT74,
-     ARCHITECTURE_DEPENDENT_EVENT75,
-     ARCHITECTURE_DEPENDENT_EVENT76,
-     ARCHITECTURE_DEPENDENT_EVENT77,
-     ARCHITECTURE_DEPENDENT_EVENT78,
-#endif
-#if defined(__ia32__)
-     ARCHITECTURE_DEPENDENT_EVENT79,
-     ARCHITECTURE_DEPENDENT_EVENT80,
-     ARCHITECTURE_DEPENDENT_EVENT81,
-     ARCHITECTURE_DEPENDENT_EVENT82,
-     ARCHITECTURE_DEPENDENT_EVENT83,
-     ARCHITECTURE_DEPENDENT_EVENT84,
-     ARCHITECTURE_DEPENDENT_EVENT85,
-     ARCHITECTURE_DEPENDENT_EVENT86,
-     ARCHITECTURE_DEPENDENT_EVENT87,
-     ARCHITECTURE_DEPENDENT_EVENT88,
-     ARCHITECTURE_DEPENDENT_EVENT89,
-     ARCHITECTURE_DEPENDENT_EVENT90,
-     ARCHITECTURE_DEPENDENT_EVENT91,
-     ARCHITECTURE_DEPENDENT_EVENT92,
-     ARCHITECTURE_DEPENDENT_EVENT93,
-     ARCHITECTURE_DEPENDENT_EVENT94,
-     ARCHITECTURE_DEPENDENT_EVENT95,
-     ARCHITECTURE_DEPENDENT_EVENT96,
-     ARCHITECTURE_DEPENDENT_EVENT97,
-     ARCHITECTURE_DEPENDENT_EVENT98,
-     ARCHITECTURE_DEPENDENT_EVENT99,
-     ARCHITECTURE_DEPENDENT_EVENT100,
-     ARCHITECTURE_DEPENDENT_EVENT101,
-     ARCHITECTURE_DEPENDENT_EVENT102,
-     ARCHITECTURE_DEPENDENT_EVENT103,
-     ARCHITECTURE_DEPENDENT_EVENT104,
-     ARCHITECTURE_DEPENDENT_EVENT105,
-     ARCHITECTURE_DEPENDENT_EVENT106,
-     ARCHITECTURE_DEPENDENT_EVENT107,
-     ARCHITECTURE_DEPENDENT_EVENT108,
-     ARCHITECTURE_DEPENDENT_EVENT109,
-     ARCHITECTURE_DEPENDENT_EVENT110,
-     ARCHITECTURE_DEPENDENT_EVENT111,
-     ARCHITECTURE_DEPENDENT_EVENT112,
-     ARCHITECTURE_DEPENDENT_EVENT113,
-     ARCHITECTURE_DEPENDENT_EVENT114,
-     ARCHITECTURE_DEPENDENT_EVENT115,
-     ARCHITECTURE_DEPENDENT_EVENT116,
-     ARCHITECTURE_DEPENDENT_EVENT117,
-     ARCHITECTURE_DEPENDENT_EVENT118,
-     ARCHITECTURE_DEPENDENT_EVENT119,
-     ARCHITECTURE_DEPENDENT_EVENT120,
-     ARCHITECTURE_DEPENDENT_EVENT121,
-     ARCHITECTURE_DEPENDENT_EVENT122,
-     ARCHITECTURE_DEPENDENT_EVENT123,
-     ARCHITECTURE_DEPENDENT_EVENT124,
-     ARCHITECTURE_DEPENDENT_EVENT125,
-     ARCHITECTURE_DEPENDENT_EVENT126,
-     ARCHITECTURE_DEPENDENT_EVENT127,
-     ARCHITECTURE_DEPENDENT_EVENT128,
-     ARCHITECTURE_DEPENDENT_EVENT129,
-     ARCHITECTURE_DEPENDENT_EVENT130,
-     ARCHITECTURE_DEPENDENT_EVENT131,
-     ARCHITECTURE_DEPENDENT_EVENT132,
-     ARCHITECTURE_DEPENDENT_EVENT133,
-     ARCHITECTURE_DEPENDENT_EVENT134,
-     ARCHITECTURE_DEPENDENT_EVENT135,
-     ARCHITECTURE_DEPENDENT_EVENT136,
-     ARCHITECTURE_DEPENDENT_EVENT137,
-     ARCHITECTURE_DEPENDENT_EVENT138,
-     ARCHITECTURE_DEPENDENT_EVENT139,
-     ARCHITECTURE_DEPENDENT_EVENT140,
-     ARCHITECTURE_DEPENDENT_EVENT141,
-     ARCHITECTURE_DEPENDENT_EVENT142,
-     ARCHITECTURE_DEPENDENT_EVENT143,
-     ARCHITECTURE_DEPENDENT_EVENT144,
-     ARCHITECTURE_DEPENDENT_EVENT145,
-     ARCHITECTURE_DEPENDENT_EVENT146,
-     ARCHITECTURE_DEPENDENT_EVENT147,
-     ARCHITECTURE_DEPENDENT_EVENT148,
-     ARCHITECTURE_DEPENDENT_EVENT149,
-     ARCHITECTURE_DEPENDENT_EVENT150,
-     ARCHITECTURE_DEPENDENT_EVENT151,
-     ARCHITECTURE_DEPENDENT_EVENT152,
-     ARCHITECTURE_DEPENDENT_EVENT153,
-     ARCHITECTURE_DEPENDENT_EVENT154,
-     ARCHITECTURE_DEPENDENT_EVENT155,
-     ARCHITECTURE_DEPENDENT_EVENT156,
-     ARCHITECTURE_DEPENDENT_EVENT157,
-     ARCHITECTURE_DEPENDENT_EVENT158,
-     ARCHITECTURE_DEPENDENT_EVENT159,
-     ARCHITECTURE_DEPENDENT_EVENT160,
-     ARCHITECTURE_DEPENDENT_EVENT161,
-     ARCHITECTURE_DEPENDENT_EVENT162,
-     ARCHITECTURE_DEPENDENT_EVENT163,
-     ARCHITECTURE_DEPENDENT_EVENT164,
-     ARCHITECTURE_DEPENDENT_EVENT165,
-     ARCHITECTURE_DEPENDENT_EVENT166,
-     ARCHITECTURE_DEPENDENT_EVENT167,
-     ARCHITECTURE_DEPENDENT_EVENT168,
-     ARCHITECTURE_DEPENDENT_EVENT169,
-     ARCHITECTURE_DEPENDENT_EVENT170,
-     ARCHITECTURE_DEPENDENT_EVENT171,
-     ARCHITECTURE_DEPENDENT_EVENT172,
-     ARCHITECTURE_DEPENDENT_EVENT173,
-     ARCHITECTURE_DEPENDENT_EVENT174,
-     ARCHITECTURE_DEPENDENT_EVENT175,
-     ARCHITECTURE_DEPENDENT_EVENT176,
-     ARCHITECTURE_DEPENDENT_EVENT177,
-     ARCHITECTURE_DEPENDENT_EVENT178,
-     ARCHITECTURE_DEPENDENT_EVENT179,
-     ARCHITECTURE_DEPENDENT_EVENT180,
-     ARCHITECTURE_DEPENDENT_EVENT181,
-     ARCHITECTURE_DEPENDENT_EVENT182,
-     ARCHITECTURE_DEPENDENT_EVENT183,
-     ARCHITECTURE_DEPENDENT_EVENT184,
-     ARCHITECTURE_DEPENDENT_EVENT185,
-     ARCHITECTURE_DEPENDENT_EVENT186,
-     ARCHITECTURE_DEPENDENT_EVENT187,
-     ARCHITECTURE_DEPENDENT_EVENT188,
-     ARCHITECTURE_DEPENDENT_EVENT189,
-     ARCHITECTURE_DEPENDENT_EVENT190,
-     ARCHITECTURE_DEPENDENT_EVENT191,
-     ARCHITECTURE_DEPENDENT_EVENT192,
-     ARCHITECTURE_DEPENDENT_EVENT193,
-     ARCHITECTURE_DEPENDENT_EVENT194,
-     ARCHITECTURE_DEPENDENT_EVENT195,
-     ARCHITECTURE_DEPENDENT_EVENT196,
-     ARCHITECTURE_DEPENDENT_EVENT197,
-     ARCHITECTURE_DEPENDENT_EVENT198,
-     ARCHITECTURE_DEPENDENT_EVENT199,
-     ARCHITECTURE_DEPENDENT_EVENT200,
-     ARCHITECTURE_DEPENDENT_EVENT201,
-     ARCHITECTURE_DEPENDENT_EVENT202,
-     ARCHITECTURE_DEPENDENT_EVENT203,
-     ARCHITECTURE_DEPENDENT_EVENT204,
-     ARCHITECTURE_DEPENDENT_EVENT205,
-     ARCHITECTURE_DEPENDENT_EVENT206,
-     ARCHITECTURE_DEPENDENT_EVENT207,
-     ARCHITECTURE_DEPENDENT_EVENT208,
-     ARCHITECTURE_DEPENDENT_EVENT209,
-     ARCHITECTURE_DEPENDENT_EVENT210,
-     ARCHITECTURE_DEPENDENT_EVENT211,
-     ARCHITECTURE_DEPENDENT_EVENT212,
-     ARCHITECTURE_DEPENDENT_EVENT213,
-     ARCHITECTURE_DEPENDENT_EVENT214,
-     ARCHITECTURE_DEPENDENT_EVENT215,
-     ARCHITECTURE_DEPENDENT_EVENT216,
-     ARCHITECTURE_DEPENDENT_EVENT217,
-     ARCHITECTURE_DEPENDENT_EVENT218,
-     ARCHITECTURE_DEPENDENT_EVENT219,
-     ARCHITECTURE_DEPENDENT_EVENT220,
-     ARCHITECTURE_DEPENDENT_EVENT221,
-     ARCHITECTURE_DEPENDENT_EVENT222,
-     ARCHITECTURE_DEPENDENT_EVENT223,
-     ARCHITECTURE_DEPENDENT_EVENT224,
-     ARCHITECTURE_DEPENDENT_EVENT225,
-     ARCHITECTURE_DEPENDENT_EVENT226,
-     ARCHITECTURE_DEPENDENT_EVENT227,
-     ARCHITECTURE_DEPENDENT_EVENT228,
-     ARCHITECTURE_DEPENDENT_EVENT229,
-     ARCHITECTURE_DEPENDENT_EVENT230,
-     ARCHITECTURE_DEPENDENT_EVENT231,
-     ARCHITECTURE_DEPENDENT_EVENT232,
-     ARCHITECTURE_DEPENDENT_EVENT233,
-     ARCHITECTURE_DEPENDENT_EVENT234,
-     ARCHITECTURE_DEPENDENT_EVENT235,
-     ARCHITECTURE_DEPENDENT_EVENT236,
-     ARCHITECTURE_DEPENDENT_EVENT237,
-     ARCHITECTURE_DEPENDENT_EVENT238,
-     ARCHITECTURE_DEPENDENT_EVENT239,
-#endif
-     LAST_EVENT
- }; };
-
 // Configuration Tokens
-struct Traits_Tokens: public Transducer_Event, public System_Event, public PMU_Event
+struct Traits_Tokens
 {
     // EPOS software architecture (aka mode)
     enum {LIBRARY, BUILTIN, KERNEL};
@@ -472,6 +194,283 @@ struct Traits_Tokens: public Transducer_Event, public System_Event, public PMU_E
 
     // SmartData predictors
     enum :unsigned char {NONE, LVP, DBP};
+
+    // Monitor events (Transducers)
+    struct Transducer_Event { enum {
+        CPU_TEMPERATURE,
+        CPU_VOLTAGE,
+    }; };
+
+   // Monitor events (System)
+    struct System_Event { enum {
+        ELAPSED_TIME,
+        DEADLINE_MISSES,
+        CPU_EXECUTION_TIME,
+        THREAD_EXECUTION_TIME,
+        RUNNING_THREAD,
+    }; };
+
+    // Monitor events (PMU)
+    struct PMU_Event { enum {
+        CPU_CYCLES,
+        UNHALTED_CYCLES,
+
+        INSTRUCTIONS_RETIRED,
+        LOAD_INSTRUCTIONS_RETIRED,                      INTEGER_LOAD_INSTRUCTIONS_RETIRED = LOAD_INSTRUCTIONS_RETIRED,
+        STORE_INSTRUCTIONS_RETIRED,                     INTEGER_STORE_INSTRUCTIONS_RETIRED = STORE_INSTRUCTIONS_RETIRED,
+        INTEGER_ARITHMETIC_INSTRUCTIONS_RETIRED,
+        INTEGER_MULTIPLICATION_INSTRUCTIONS_RETIRED,
+        INTEGER_DIVISION_INSTRUCTIONS_RETIRED,
+        FPU_INSTRUCTIONS_RETIRED,
+        SIMD_INSTRUCTIONS_RETIRED,
+        ATOMIC_MEMEMORY_INSTRUCTIONS_RETIRED,
+
+        BRANCHES,
+        IMIDIATE_BRANCHES,
+        CONDITIONAL_BRANCHES,
+        BRANCH_MISPREDICTIONS,
+        BRANCH_DIRECTION_MISPREDICTIONS,
+        CONDITIONAL_BRANCH_MISPREDICTIONS,
+
+        EXCEPTIONS,
+        INTERRUPTS,
+
+        L1_CACHE_HITS,
+        L1_CACHE_MISSES,
+        L1_DATA_CACHE_MISSES,
+        L1_DATA_CACHE_WRITEBACKS,
+        L1_INSTRUCTION_CACHE_MISSES,                    INSTRUCTION_CACHE_MISSES = L1_INSTRUCTION_CACHE_MISSES,
+        L2_CACHE_HITS,
+        L2_CACHE_MISSES,
+        L2_DATA_CACHE_MISSES,
+        L2_DATA_CACHE_WRITEBACKS,
+        L3_CACHE_HITS,
+        L3_CACHE_MISSES,                                LAST_LEVEL_CACHE_HITS = L3_CACHE_HITS, LAST_LEVEL_CACHE_MISSES = L3_CACHE_MISSES, CACHE_MISSES = LAST_LEVEL_CACHE_MISSES, MEMORY_ACCESSES = LAST_LEVEL_CACHE_MISSES, DATA_MEMORY_ACCESSES = LAST_LEVEL_CACHE_MISSES,
+
+        INSTRUCTION_MEMORY_ACCESSES,
+        UNCACHED_MEMORY_ACCESSES,
+        UNALIGNED_MEMORY_ACCESSES,
+
+        BUS_CYCLES,
+        BUS_ACCESSES,
+        TLB_MISSES,
+        DATA_TLB_MISSES = TLB_MISSES,                   MMU_MISSES = TLB_MISSES,
+        INSTRUCTION_TLB_MISSES,
+        MEMORY_ERRORS,
+
+        STALL_CYCLES,
+        STALL_CYCLES_CACHE,                             STALL_CYCLES_INSTRUCTION_CACHE = STALL_CYCLES_CACHE,
+        STALL_CYCLES_DATA_CACHE,
+        STALL_CYCLES_TLB,
+        STALL_CYCLES_MEMORY,
+        PIPELINE_SERIALIZATIONS,    // ISB
+        BUS_SERIALIZATION,          // DSB = 44
+
+#if defined(__ia32__) || defined(__riscv__) || defined(__cortex_a__)
+        ARCHITECTURE_DEPENDENT_EVENT45,
+        ARCHITECTURE_DEPENDENT_EVENT46,
+        ARCHITECTURE_DEPENDENT_EVENT47,
+        ARCHITECTURE_DEPENDENT_EVENT48,
+        ARCHITECTURE_DEPENDENT_EVENT49,
+        ARCHITECTURE_DEPENDENT_EVENT50,
+        ARCHITECTURE_DEPENDENT_EVENT51,
+        ARCHITECTURE_DEPENDENT_EVENT52,
+        ARCHITECTURE_DEPENDENT_EVENT53,
+        ARCHITECTURE_DEPENDENT_EVENT54,
+        ARCHITECTURE_DEPENDENT_EVENT55,
+#endif
+#if defined(__ia32__) || defined(__cortex_a__)
+        ARCHITECTURE_DEPENDENT_EVENT56,
+        ARCHITECTURE_DEPENDENT_EVENT57,
+        ARCHITECTURE_DEPENDENT_EVENT58,
+        ARCHITECTURE_DEPENDENT_EVENT59,
+        ARCHITECTURE_DEPENDENT_EVENT60,
+        ARCHITECTURE_DEPENDENT_EVENT61,
+        ARCHITECTURE_DEPENDENT_EVENT62,
+        ARCHITECTURE_DEPENDENT_EVENT63,
+        ARCHITECTURE_DEPENDENT_EVENT64,
+        ARCHITECTURE_DEPENDENT_EVENT65,
+        ARCHITECTURE_DEPENDENT_EVENT66,
+        ARCHITECTURE_DEPENDENT_EVENT67,
+        ARCHITECTURE_DEPENDENT_EVENT68,
+        ARCHITECTURE_DEPENDENT_EVENT69,
+#endif
+#if defined(__ia32__) || defined(__cortex_a9__)
+        ARCHITECTURE_DEPENDENT_EVENT70,
+        ARCHITECTURE_DEPENDENT_EVENT71,
+        ARCHITECTURE_DEPENDENT_EVENT72,
+        ARCHITECTURE_DEPENDENT_EVENT73,
+        ARCHITECTURE_DEPENDENT_EVENT74,
+        ARCHITECTURE_DEPENDENT_EVENT75,
+        ARCHITECTURE_DEPENDENT_EVENT76,
+        ARCHITECTURE_DEPENDENT_EVENT77,
+        ARCHITECTURE_DEPENDENT_EVENT78,
+#endif
+#if defined(__ia32__)
+        ARCHITECTURE_DEPENDENT_EVENT79,
+        ARCHITECTURE_DEPENDENT_EVENT80,
+        ARCHITECTURE_DEPENDENT_EVENT81,
+        ARCHITECTURE_DEPENDENT_EVENT82,
+        ARCHITECTURE_DEPENDENT_EVENT83,
+        ARCHITECTURE_DEPENDENT_EVENT84,
+        ARCHITECTURE_DEPENDENT_EVENT85,
+        ARCHITECTURE_DEPENDENT_EVENT86,
+        ARCHITECTURE_DEPENDENT_EVENT87,
+        ARCHITECTURE_DEPENDENT_EVENT88,
+        ARCHITECTURE_DEPENDENT_EVENT89,
+        ARCHITECTURE_DEPENDENT_EVENT90,
+        ARCHITECTURE_DEPENDENT_EVENT91,
+        ARCHITECTURE_DEPENDENT_EVENT92,
+        ARCHITECTURE_DEPENDENT_EVENT93,
+        ARCHITECTURE_DEPENDENT_EVENT94,
+        ARCHITECTURE_DEPENDENT_EVENT95,
+        ARCHITECTURE_DEPENDENT_EVENT96,
+        ARCHITECTURE_DEPENDENT_EVENT97,
+        ARCHITECTURE_DEPENDENT_EVENT98,
+        ARCHITECTURE_DEPENDENT_EVENT99,
+        ARCHITECTURE_DEPENDENT_EVENT100,
+        ARCHITECTURE_DEPENDENT_EVENT101,
+        ARCHITECTURE_DEPENDENT_EVENT102,
+        ARCHITECTURE_DEPENDENT_EVENT103,
+        ARCHITECTURE_DEPENDENT_EVENT104,
+        ARCHITECTURE_DEPENDENT_EVENT105,
+        ARCHITECTURE_DEPENDENT_EVENT106,
+        ARCHITECTURE_DEPENDENT_EVENT107,
+        ARCHITECTURE_DEPENDENT_EVENT108,
+        ARCHITECTURE_DEPENDENT_EVENT109,
+        ARCHITECTURE_DEPENDENT_EVENT110,
+        ARCHITECTURE_DEPENDENT_EVENT111,
+        ARCHITECTURE_DEPENDENT_EVENT112,
+        ARCHITECTURE_DEPENDENT_EVENT113,
+        ARCHITECTURE_DEPENDENT_EVENT114,
+        ARCHITECTURE_DEPENDENT_EVENT115,
+        ARCHITECTURE_DEPENDENT_EVENT116,
+        ARCHITECTURE_DEPENDENT_EVENT117,
+        ARCHITECTURE_DEPENDENT_EVENT118,
+        ARCHITECTURE_DEPENDENT_EVENT119,
+        ARCHITECTURE_DEPENDENT_EVENT120,
+        ARCHITECTURE_DEPENDENT_EVENT121,
+        ARCHITECTURE_DEPENDENT_EVENT122,
+        ARCHITECTURE_DEPENDENT_EVENT123,
+        ARCHITECTURE_DEPENDENT_EVENT124,
+        ARCHITECTURE_DEPENDENT_EVENT125,
+        ARCHITECTURE_DEPENDENT_EVENT126,
+        ARCHITECTURE_DEPENDENT_EVENT127,
+        ARCHITECTURE_DEPENDENT_EVENT128,
+        ARCHITECTURE_DEPENDENT_EVENT129,
+        ARCHITECTURE_DEPENDENT_EVENT130,
+        ARCHITECTURE_DEPENDENT_EVENT131,
+        ARCHITECTURE_DEPENDENT_EVENT132,
+        ARCHITECTURE_DEPENDENT_EVENT133,
+        ARCHITECTURE_DEPENDENT_EVENT134,
+        ARCHITECTURE_DEPENDENT_EVENT135,
+        ARCHITECTURE_DEPENDENT_EVENT136,
+        ARCHITECTURE_DEPENDENT_EVENT137,
+        ARCHITECTURE_DEPENDENT_EVENT138,
+        ARCHITECTURE_DEPENDENT_EVENT139,
+        ARCHITECTURE_DEPENDENT_EVENT140,
+        ARCHITECTURE_DEPENDENT_EVENT141,
+        ARCHITECTURE_DEPENDENT_EVENT142,
+        ARCHITECTURE_DEPENDENT_EVENT143,
+        ARCHITECTURE_DEPENDENT_EVENT144,
+        ARCHITECTURE_DEPENDENT_EVENT145,
+        ARCHITECTURE_DEPENDENT_EVENT146,
+        ARCHITECTURE_DEPENDENT_EVENT147,
+        ARCHITECTURE_DEPENDENT_EVENT148,
+        ARCHITECTURE_DEPENDENT_EVENT149,
+        ARCHITECTURE_DEPENDENT_EVENT150,
+        ARCHITECTURE_DEPENDENT_EVENT151,
+        ARCHITECTURE_DEPENDENT_EVENT152,
+        ARCHITECTURE_DEPENDENT_EVENT153,
+        ARCHITECTURE_DEPENDENT_EVENT154,
+        ARCHITECTURE_DEPENDENT_EVENT155,
+        ARCHITECTURE_DEPENDENT_EVENT156,
+        ARCHITECTURE_DEPENDENT_EVENT157,
+        ARCHITECTURE_DEPENDENT_EVENT158,
+        ARCHITECTURE_DEPENDENT_EVENT159,
+        ARCHITECTURE_DEPENDENT_EVENT160,
+        ARCHITECTURE_DEPENDENT_EVENT161,
+        ARCHITECTURE_DEPENDENT_EVENT162,
+        ARCHITECTURE_DEPENDENT_EVENT163,
+        ARCHITECTURE_DEPENDENT_EVENT164,
+        ARCHITECTURE_DEPENDENT_EVENT165,
+        ARCHITECTURE_DEPENDENT_EVENT166,
+        ARCHITECTURE_DEPENDENT_EVENT167,
+        ARCHITECTURE_DEPENDENT_EVENT168,
+        ARCHITECTURE_DEPENDENT_EVENT169,
+        ARCHITECTURE_DEPENDENT_EVENT170,
+        ARCHITECTURE_DEPENDENT_EVENT171,
+        ARCHITECTURE_DEPENDENT_EVENT172,
+        ARCHITECTURE_DEPENDENT_EVENT173,
+        ARCHITECTURE_DEPENDENT_EVENT174,
+        ARCHITECTURE_DEPENDENT_EVENT175,
+        ARCHITECTURE_DEPENDENT_EVENT176,
+        ARCHITECTURE_DEPENDENT_EVENT177,
+        ARCHITECTURE_DEPENDENT_EVENT178,
+        ARCHITECTURE_DEPENDENT_EVENT179,
+        ARCHITECTURE_DEPENDENT_EVENT180,
+        ARCHITECTURE_DEPENDENT_EVENT181,
+        ARCHITECTURE_DEPENDENT_EVENT182,
+        ARCHITECTURE_DEPENDENT_EVENT183,
+        ARCHITECTURE_DEPENDENT_EVENT184,
+        ARCHITECTURE_DEPENDENT_EVENT185,
+        ARCHITECTURE_DEPENDENT_EVENT186,
+        ARCHITECTURE_DEPENDENT_EVENT187,
+        ARCHITECTURE_DEPENDENT_EVENT188,
+        ARCHITECTURE_DEPENDENT_EVENT189,
+        ARCHITECTURE_DEPENDENT_EVENT190,
+        ARCHITECTURE_DEPENDENT_EVENT191,
+        ARCHITECTURE_DEPENDENT_EVENT192,
+        ARCHITECTURE_DEPENDENT_EVENT193,
+        ARCHITECTURE_DEPENDENT_EVENT194,
+        ARCHITECTURE_DEPENDENT_EVENT195,
+        ARCHITECTURE_DEPENDENT_EVENT196,
+        ARCHITECTURE_DEPENDENT_EVENT197,
+        ARCHITECTURE_DEPENDENT_EVENT198,
+        ARCHITECTURE_DEPENDENT_EVENT199,
+        ARCHITECTURE_DEPENDENT_EVENT200,
+        ARCHITECTURE_DEPENDENT_EVENT201,
+        ARCHITECTURE_DEPENDENT_EVENT202,
+        ARCHITECTURE_DEPENDENT_EVENT203,
+        ARCHITECTURE_DEPENDENT_EVENT204,
+        ARCHITECTURE_DEPENDENT_EVENT205,
+        ARCHITECTURE_DEPENDENT_EVENT206,
+        ARCHITECTURE_DEPENDENT_EVENT207,
+        ARCHITECTURE_DEPENDENT_EVENT208,
+        ARCHITECTURE_DEPENDENT_EVENT209,
+        ARCHITECTURE_DEPENDENT_EVENT210,
+        ARCHITECTURE_DEPENDENT_EVENT211,
+        ARCHITECTURE_DEPENDENT_EVENT212,
+        ARCHITECTURE_DEPENDENT_EVENT213,
+        ARCHITECTURE_DEPENDENT_EVENT214,
+        ARCHITECTURE_DEPENDENT_EVENT215,
+        ARCHITECTURE_DEPENDENT_EVENT216,
+        ARCHITECTURE_DEPENDENT_EVENT217,
+        ARCHITECTURE_DEPENDENT_EVENT218,
+        ARCHITECTURE_DEPENDENT_EVENT219,
+        ARCHITECTURE_DEPENDENT_EVENT220,
+        ARCHITECTURE_DEPENDENT_EVENT221,
+        ARCHITECTURE_DEPENDENT_EVENT222,
+        ARCHITECTURE_DEPENDENT_EVENT223,
+        ARCHITECTURE_DEPENDENT_EVENT224,
+        ARCHITECTURE_DEPENDENT_EVENT225,
+        ARCHITECTURE_DEPENDENT_EVENT226,
+        ARCHITECTURE_DEPENDENT_EVENT227,
+        ARCHITECTURE_DEPENDENT_EVENT228,
+        ARCHITECTURE_DEPENDENT_EVENT229,
+        ARCHITECTURE_DEPENDENT_EVENT230,
+        ARCHITECTURE_DEPENDENT_EVENT231,
+        ARCHITECTURE_DEPENDENT_EVENT232,
+        ARCHITECTURE_DEPENDENT_EVENT233,
+        ARCHITECTURE_DEPENDENT_EVENT234,
+        ARCHITECTURE_DEPENDENT_EVENT235,
+        ARCHITECTURE_DEPENDENT_EVENT236,
+        ARCHITECTURE_DEPENDENT_EVENT237,
+        ARCHITECTURE_DEPENDENT_EVENT238,
+        ARCHITECTURE_DEPENDENT_EVENT239,
+#endif
+        LAST_EVENT
+    }; };
 };
 
 template<typename T>
diff --git a/makedefs b/makedefs
index 6d524ac..a2d5cf7 100644
--- a/makedefs
+++ b/makedefs
@@ -101,7 +101,7 @@ ia32_COMP_PREFIX	:= /usr/bin/x86_64-linux-gnu-
 armv7_COMP_PREFIX	:= /usr/bin/arm-none-eabi-
 armv8_COMP_PREFIX	:= /usr/bin/aarch64-linux-gnu-
 rv32_COMP_PREFIX	:= /usr/local/rv32/bin/riscv32-unknown-linux-gnu-
-rv64_COMP_PREFIX	:= /usr/local/rv64/bin/riscv64-unknown-linux-gnu-
+rv64_COMP_PREFIX	:= /usr/bin/riscv64-linux-gnu-
 COMP_PREFIX		= $($(ARCH)_COMP_PREFIX)
 
 # Architecture specifics
@@ -139,7 +139,7 @@ endif
 ifeq ($(MMOD),zynq)
 cortex_CC_FLAGS		:= -mcpu=cortex-a9
 cortex_AS_FLAGS		:= -mcpu=cortex-a9
-cortex_EMULATOR		= qemu-system-arm $(QEMU_DEBUG) -machine xilinx-zynq-a9 -smp $(CPUS) -m $(MEM_SIZE)k -serial null -serial mon:stdio -nographic -no-reboot $(BOOT_ROM) -kernel 
+cortex_EMULATOR		= qemu-system-arm $(QEMU_DEBUG) -machine xilinx-zynq-a9  -smp $(CPUS) -m $(MEM_SIZE)k -serial null -serial mon:stdio -nographic -no-reboot $(BOOT_ROM) -kernel 
 cortex_DEBUGGER		:= gdb
 cortex_FLASHER		= $(TLS)/eposflash/eposflash-$(MMOD) -d /dev/ttyACM0 -f
 cortex_MAGIC		:= --omagic
@@ -197,7 +197,7 @@ riscv_CC_FLAGS		:= -march=rv32gc -mabi=ilp32f -Wl, -mno-relax
 riscv_AS_FLAGS		:= -march=rv32gc -mabi=ilp32f
 riscv_LD_FLAGS		:= -m elf32lriscv_ilp32f --no-relax
 riscv_EMULATOR		= qemu-system-riscv32 $(QEMU_DEBUG) -machine sifive_e -m $(MEM_SIZE)k -serial mon:stdio -bios none -nographic -no-reboot $(BOOT_ROM) -kernel 
-riscv_DEBUGGER		:= $(COMP_PREFIX)gdb
+riscv_DEBUGGER		:= gdb-multiarch -ex "set architecture riscv:rv32"
 riscv_FLASHER		:= 
 riscv_MAGIC		:= --nmagic
 riscv_CODE_NAME		:= .init
@@ -215,9 +215,9 @@ else
 riscv_CC_FLAGS      := -march=rv32gc -mabi=ilp32d -Wl, -mno-relax
 riscv_AS_FLAGS      := -march=rv32gc -mabi=ilp32d
 riscv_LD_FLAGS      := -m elf32lriscv_ilp32f --no-relax
-riscv_EMULATOR		= qemu-system-riscv32 $(QEMU_DEBUG) -machine virt -cpu rv32 -smp $(CPUS) -m $(MEM_SIZE)k -serial mon:stdio -bios none -nographic -no-reboot $(BOOT_ROM) -kernel 
+riscv_EMULATOR     = qemu-system-riscv32 $(QEMU_DEBUG) -machine sifive_u -cpu rv32 -smp 2 -m $(MEM_SIZE)k -serial mon:stdio -bios none -nographic -no-reboot -kernel  
 endif 
-riscv_DEBUGGER		:= $(COMP_PREFIX)gdb
+riscv_DEBUGGER		:= gdb-multiarch -ex "set architecture riscv:rv32"
 riscv_FLASHER		:= 
 riscv_MAGIC		:= --nmagic
 riscv_CODE_NAME		:= .init
diff --git a/src/api/thread.cc b/src/api/thread.cc
index 28b28d0..98a0630 100644
--- a/src/api/thread.cc
+++ b/src/api/thread.cc
@@ -337,7 +337,7 @@ void Thread::dispatch(Thread * prev, Thread * next, bool charge)
         next->_state = RUNNING;
 
         db<Thread>(TRC) << "Thread::dispatch(prev=" << prev << ",next=" << next << ")" << endl;
-        if(Traits<Thread>::debugged && Traits<Debug>::info) {
+        if(Traits<Thread>::debugged && Traits<Debug>::trace) {
             CPU::Context tmp;
             tmp.save();
             db<Thread>(INF) << "Thread::dispatch:prev={" << prev << ",ctx=" << tmp << "}" << endl;
diff --git a/src/architecture/armv7/armv7_cpu_init.cc b/src/architecture/armv7/armv7_cpu_init.cc
index d66cede..24f598f 100644
--- a/src/architecture/armv7/armv7_cpu_init.cc
+++ b/src/architecture/armv7/armv7_cpu_init.cc
@@ -10,10 +10,12 @@ void CPU::init()
 {
     db<Init, CPU>(TRC) << "CPU::init()" << endl;
 
-    if(Traits<MMU>::enabled)
-        MMU::init();
-    else
-        db<Init, MMU>(WRN) << "MMU is disabled!" << endl;
+    if(CPU::id() == 0) {
+        if(Traits<MMU>::enabled)
+            MMU::init();
+        else
+            db<Init, MMU>(WRN) << "MMU is disabled!" << endl;
+    }
 
 #ifdef __cortex_a__
     if(Traits<FPU>::enabled)
diff --git a/src/architecture/armv8/armv8_cpu_init.cc b/src/architecture/armv8/armv8_cpu_init.cc
index 994471a..b9c9e50 100644
--- a/src/architecture/armv8/armv8_cpu_init.cc
+++ b/src/architecture/armv8/armv8_cpu_init.cc
@@ -10,10 +10,12 @@ void CPU::init()
 {
     db<Init, CPU>(TRC) << "CPU::init()" << endl;
 
-    if(Traits<MMU>::enabled)
-        MMU::init();
-    else
-        db<Init, MMU>(WRN) << "MMU is disabled!" << endl;
+    if(CPU::id() == 0) {
+        if(Traits<MMU>::enabled)
+            MMU::init();
+        else
+            db<Init, MMU>(WRN) << "MMU is disabled!" << endl;
+    }
 
 //#ifdef __cortex_a__
 //    if(Traits<FPU>::enabled)
diff --git a/src/architecture/ia32/ia32_cpu_init.cc b/src/architecture/ia32/ia32_cpu_init.cc
index 589b5bb..f6787ad 100644
--- a/src/architecture/ia32/ia32_cpu_init.cc
+++ b/src/architecture/ia32/ia32_cpu_init.cc
@@ -17,12 +17,11 @@ void CPU::init()
     // Initialize the MMU
     if(Traits<MMU>::enabled)
         MMU::init();
-    else
-        db<Init, MMU>(WRN) << "MMU is disabled!" << endl;
 
     // Initialize the PMU	
     if(Traits<PMU>::enabled)
         PMU::init();
 }
 
+
 __END_SYS
diff --git a/src/architecture/rv32/rv32_cpu.cc b/src/architecture/rv32/rv32_cpu.cc
index 6b04a60..14abecb 100644
--- a/src/architecture/rv32/rv32_cpu.cc
+++ b/src/architecture/rv32/rv32_cpu.cc
@@ -10,9 +10,11 @@ unsigned int CPU::_bus_clock;
 
 void CPU::Context::save() volatile
 {
-    ASM("       sw       x1,    0(a0)           \n"     // push RA as PC
-        "       csrr     x3,  mstatus           \n"
-        "       sw       x3,    4(a0)           \n"     // push ST
+    ASM("       sw       x1,    0(a0)           \n");   // push RA as PC
+
+    ASM("       csrr     x3,  mstatus           \n");
+
+    ASM("       sw       x3,    4(a0)           \n"     // push ST
         "       sw       x1,    8(a0)           \n"     // push RA
         "       sw       x5,   12(a0)           \n"     // push x5-x31
         "       sw       x6,   16(a0)           \n"
diff --git a/src/architecture/rv32/rv32_cpu_init.cc b/src/architecture/rv32/rv32_cpu_init.cc
index 8c05061..9488668 100644
--- a/src/architecture/rv32/rv32_cpu_init.cc
+++ b/src/architecture/rv32/rv32_cpu_init.cc
@@ -12,8 +12,6 @@ void CPU::init()
 
     if(Traits<MMU>::enabled)
         MMU::init();
-    else
-        db<Init, MMU>(WRN) << "MMU is disabled!" << endl;
 
 #ifdef __TSC_H
     if(Traits<TSC>::enabled)
diff --git a/src/architecture/rv32/rv32_pmu_init.cc b/src/architecture/rv32/rv32_pmu_init.cc
new file mode 100644
index 0000000..78d8ed5
--- /dev/null
+++ b/src/architecture/rv32/rv32_pmu_init.cc
@@ -0,0 +1,14 @@
+// EPOS RISC-V 32 PMU Mediator Initialization
+
+#include <architecture/rv32/rv32_pmu.h>
+
+__BEGIN_SYS
+
+void RV32_PMU::init()
+{
+    db<Init, PMU>(TRC) << "PMU::init()" << endl;
+
+    mcounteren(CYCLES | TIME | INSTRUCTIONS_RETIRED);
+}
+
+__END_SYS
diff --git a/src/architecture/rv64/makefile b/src/architecture/rv64/makefile
deleted file mode 100644
index 6f28d02..0000000
--- a/src/architecture/rv64/makefile
+++ /dev/null
@@ -1,30 +0,0 @@
-# EPOS RISC-V 64 Architecture Makefile
-
-include ../../../makedefs
-
-OBJS := $(subst .cc,.o,$(shell find *.cc | grep -v _init | grep -v _test))
-CRTS := $(subst .S,.o,$(shell find *.S | grep crt)) $(ARCH)_crtbegin.o $(ARCH)_crtend.o 
-CRTSI := $(subst .S,.s,$(shell find *.S | grep crt))
-INITS := $(subst .cc,.o,$(shell find *.cc | grep _init))
-
-all:		crts $(LIBARCH) $(LIBINIT)
-
-crts:		$(CRTS)
-		$(INSTALL) $(ARCH)_crt0.o $(LIB)/crt0_$(MMOD).o
-		$(INSTALL) $(ARCH)_crtbegin.o $(LIB)/crtbegin_$(MMOD).o
-		$(INSTALL) $(ARCH)_crtend.o $(LIB)/crtend_$(MMOD).o
-
-.INTERMEDIATE:	$(CRTSI)
-
-$(LIBARCH):	$(LIBARCH)($(OBJS))
-
-$(LIBINIT):	$(LIBINIT)($(INITS))
-
-$(ARCH)_crtbegin.o: ../common/crtbegin.c
-		$(CC) $(CCFLAGS) $< -o $@
-
-$(ARCH)_crtend.o: ../common/crtend.c
-		$(CC) $(CCFLAGS) $< -o $@
-
-clean:
-		$(CLEAN) *.o *.s *_test
diff --git a/src/architecture/rv64/rv64_cpu.cc b/src/architecture/rv64/rv64_cpu.cc
deleted file mode 100644
index bcdbe1b..0000000
--- a/src/architecture/rv64/rv64_cpu.cc
+++ /dev/null
@@ -1,69 +0,0 @@
-// EPOS RISC-V 64 CPU Mediator Implementation
-
-#include <architecture/rv64/rv64_cpu.h>
-#include <system.h>
-
-__BEGIN_SYS
-
-unsigned int CPU::_cpu_clock;
-unsigned int CPU::_bus_clock;
-
-void CPU::Context::save() volatile
-{
-    ASM("       sd       x1,    0(a0)           \n"     // push RA as PC
-        "       csrr     x3,  mstatus           \n"
-        "       sd       x3,    8(sp)           \n"     // push ST
-        "       sd       x1,   16(sp)           \n"     // push RA
-        "       sd       x5,   24(sp)           \n"     // push x5-x31
-        "       sd       x6,   32(sp)           \n"
-        "       sd       x7,   40(sp)           \n"
-        "       sd       x8,   48(sp)           \n"
-        "       sd       x9,   56(sp)           \n"
-        "       sd      x10,   64(sp)           \n"
-        "       sd      x11,   72(sp)           \n"
-        "       sd      x12,   80(sp)           \n"
-        "       sd      x13,   88(sp)           \n"
-        "       sd      x14,   96(sp)           \n"
-        "       sd      x15,  104(sp)           \n"
-        "       sd      x16,  112(sp)           \n"
-        "       sd      x17,  120(sp)           \n"
-        "       sd      x18,  128(sp)           \n"
-        "       sd      x19,  136(sp)           \n"
-        "       sd      x20,  144(sp)           \n"
-        "       sd      x21,  152(sp)           \n"
-        "       sd      x22,  160(sp)           \n"
-        "       sd      x23,  168(sp)           \n"
-        "       sd      x24,  176(sp)           \n"
-        "       sd      x25,  184(sp)           \n"
-        "       sd      x26,  192(sp)           \n"
-        "       sd      x27,  200(sp)           \n"
-        "       sd      x28,  208(sp)           \n"
-        "       sd      x29,  216(sp)           \n"
-        "       sd      x30,  224(sp)           \n"
-        "       sd      x31,  232(sp)           \n"
-        "       ret                             \n");
-}
-
-// Context load does not verify if interrupts were previously enabled by the Context's constructor
-// We are setting mstatus to MPP | MPIE, therefore, interrupts will be enabled only after mret
-void CPU::Context::load() const volatile
-{
-    sp(Log_Addr(this));
-    pop();
-    iret();
-}
-
-void CPU::switch_context(Context ** o, Context * n)     // "o" is in a0 and "n" is in a1
-{   
-    // Push the context into the stack and update "o"
-    Context::push();
-    ASM("sd sp, 0(a0)");   // update Context * volatile * o, which is in a0
-
-    // Set the stack pointer to "n" and pop the context from the stack
-    ASM("mv sp, a1");   // "n" is in a1
-    Context::pop();
-    iret();
-}
-
-__END_SYS
-
diff --git a/src/architecture/rv64/rv64_cpu_init.cc b/src/architecture/rv64/rv64_cpu_init.cc
deleted file mode 100644
index 64c1621..0000000
--- a/src/architecture/rv64/rv64_cpu_init.cc
+++ /dev/null
@@ -1,29 +0,0 @@
-// EPOS RISC-V 64 CPU Mediator Initialization
-
-#include <architecture.h>
-
-extern "C" { void __epos_library_app_entry(void); }
-
-__BEGIN_SYS
-
-void CPU::init()
-{
-    db<Init, CPU>(TRC) << "CPU::init()" << endl;
-
-    if(Traits<MMU>::enabled)
-        MMU::init();
-    else
-        db<Init, MMU>(WRN) << "MMU is disabled!" << endl;
-
-#ifdef __TSC_H
-    if(Traits<TSC>::enabled)
-        TSC::init();
-#endif
-
-#ifdef __PMU_H
-    if(Traits<PMU>::enabled)
-        PMU::init();
-#endif
-}
-
-__END_SYS
diff --git a/src/architecture/rv64/rv64_crt0.S b/src/architecture/rv64/rv64_crt0.S
deleted file mode 100644
index a8d71ab..0000000
--- a/src/architecture/rv64/rv64_crt0.S
+++ /dev/null
@@ -1,24 +0,0 @@
-// EPOS RISC-V 64 Program Starter
-
-        .file "rv64_crt0.S"
-
-        .section .text
-        .align  8
-        .global _start
-        .type   _start, function
-_start:
-        // Temporary stack(s) for INIT were created and configure by SETUP
-        // BSS was cleared by SETUP
-        call      _init
-
-        .align  8
-        .globl  __epos_app_entry
-        .type   __epos_app_entry, function
-__epos_app_entry:
-        // Main's stack was allocated by Thread::init()
-        call    main
-        addi    sp, sp, -8
-        sd      a0, 0(sp)   // save main's return value to be used by exit()
-        call    _fini
-        ld      a0, 0(sp)
-        call    _exit
diff --git a/src/architecture/rv64/rv64_pmu.cc b/src/architecture/rv64/rv64_pmu.cc
deleted file mode 100644
index 17ba9bc..0000000
--- a/src/architecture/rv64/rv64_pmu.cc
+++ /dev/null
@@ -1,73 +0,0 @@
-// EPOS RISC-V 64 PMU Mediator
-
-#include <architecture/rv64/rv64_pmu.h>
-
-__BEGIN_SYS
-
-const RV32_PMU::Event RV32_PMU::_events[EVENTS] = {
-    TIME,                                       // CPU_CYCLES
-    CYCLES,                                     // UNHALTED_CYCLES
-
-    INSTRUCTIONS_RETIRED,                       // INSTRUCTIONS_RETIRED
-    INTEGER_LOAD_INSTRUCTIONS_RETIRED,          // LOAD_INSTRUCTIONS_RETIRED
-    INTEGER_STORE_INSTRUCTIONS_RETIRED,         // STORE_INSTRUCTIONS_RETIRED
-    INTEGER_ARITHMETIC_INSTRUCTIONS_RETIRED,    // INTEGER_ARITHMETIC_INSTRUCTIONS_RETIRED
-    INTEGER_MULTIPLICATION_INSTRUCTIONS_RETIRED,// INTEGER_MULTIPLICATION_INSTRUCTIONS_RETIRED
-    INTEGER_DIVISION_INSTRUCTIONS_RETIRED,      // INTEGER_DIVISION_INSTRUCTIONS_RETIRED
-    UNSUPORTED_EVENT,                           // FPU_INSTRUCTIONS_RETIRED
-    UNSUPORTED_EVENT,                           // SIMD_INSTRUCTIONS_RETIRED
-    ATOMIC_MEMEMORY_INSTRUCTIONS_RETIRED,       // ATOMIC_MEMEMORY_INSTRUCTIONS_RETIRED
-
-    UNSUPORTED_EVENT,                           // BRANCHES
-    CONDITIONAL_BRANCHES_RETIRED,               // CONDITIONAL_BRANCHES
-    UNSUPORTED_EVENT,                           // PREDICTABLE_BRANCHES
-    UNSUPORTED_EVENT,                           // IMIDIATE_BRANCHES
-    BRANCH_JUMP_TARGET_MISPREDICTION,           // BRANCH_MISPREDICTIONS
-    BRANCH_DIRECTION_MISPREDICTION,             // BRANCH_DIRECTION_MISPREDICTIONS
-
-    EXCEPTIONS_TAKEN,                           // EXCEPTIONS
-    UNSUPORTED_EVENT,                           // INTERRUPTS
-
-    UNSUPORTED_EVENT,                           // L1_CACHE_HITS
-    UNSUPORTED_EVENT,                           // L1_CACHE_MISSES
-    UNSUPORTED_EVENT,                           // L1_DATA_CACHE_MISSES
-    UNSUPORTED_EVENT,                           // L1_DATA_CACHE_WRITEBACKS
-    INSTRUCTION_CACHE_MISS,                     // L1_INSTRUCTION_CACHE_MISSES
-    UNSUPORTED_EVENT,                           // L2_CACHE_HITS
-    UNSUPORTED_EVENT,                           // L2_CACHE_MISSES
-    UNSUPORTED_EVENT,                           // L2_DATA_CACHE_MISSES
-    UNSUPORTED_EVENT,                           // L2_DATA_CACHE_WRITEBACKS
-    UNSUPORTED_EVENT,                           // L3_CACHE_HITS
-    UNSUPORTED_EVENT,                           // L3_CACHE_MISSES
-    UNSUPORTED_EVENT,                           // INSTRUCTION_MEMORY_ACCESSES
-    UNSUPORTED_EVENT,                           // UNCACHED_MEMORY_ACCESSES
-    UNSUPORTED_EVENT,                           // UNALIGNED_MEMORY_ACCESSES
-
-    UNSUPORTED_EVENT,                           // BUS_CYCLES
-    UNSUPORTED_EVENT,                           // BUS_ACCESSES
-    UNSUPORTED_EVENT,                           // TLB_MISSES
-    UNSUPORTED_EVENT,                           // INSTRUCTION_TLB_MISSES
-    UNSUPORTED_EVENT,                           // MEMORY_ERRORS
-
-    UNSUPORTED_EVENT,                           // STALL_CYCLES
-    UNSUPORTED_EVENT,                           // STALL_CYCLES_CACHE
-    UNSUPORTED_EVENT,                           // STALL_CYCLES_DATA_CACHE
-    UNSUPORTED_EVENT,                           // STALL_CYCLES_TLB
-    UNSUPORTED_EVENT,                           // STALL_CYCLES_MEMORY
-    UNSUPORTED_EVENT,                           // PIPELINE_SERIALIZATIONS
-    UNSUPORTED_EVENT,                           // BUS_SERIALIZATION
-
-    SYSTEM_INSTRUCTIONS_RETIRED,                // ARCHITECTURE_DEPENDENT_EVENT45
-    JAL_INSTRUCTIONS_RETIRED,                   // ARCHITECTURE_DEPENDENT_EVENT46
-    JALR_INSTRUCTIONS_RETIRED,                  // ARCHITECTURE_DEPENDENT_EVENT47
-    LOAD_USE_INTERLOCK,                         // ARCHITECTURE_DEPENDENT_EVENT48
-    LONG_LATENCY_INTERLOCK,                     // ARCHITECTURE_DEPENDENT_EVENT49
-    CSR_READ_INTERLOCK,                         // ARCHITECTURE_DEPENDENT_EVENT50
-    INSTRUCTION_CACHE_ITIM_BUSY,                // ARCHITECTURE_DEPENDENT_EVENT51
-    DATA_CACHE_DTIM_BUSY,                       // ARCHITECTURE_DEPENDENT_EVENT52
-    PIPELINE_FLUSH_FROM_CSR_WRITE,              // ARCHITECTURE_DEPENDENT_EVENT53
-    PIPELINE_FLUSH_FROM_OTHER_EVENT,            // ARCHITECTURE_DEPENDENT_EVENT54
-    INTEGER_MULTIPLICATION_INTERLOCK            // ARCHITECTURE_DEPENDENT_EVENT55
-};
-
-__END_SYS
diff --git a/src/machine/cortex/cortex_timer.cc b/src/machine/cortex/cortex_timer.cc
index 7c44ba2..e1c472c 100644
--- a/src/machine/cortex/cortex_timer.cc
+++ b/src/machine/cortex/cortex_timer.cc
@@ -1,6 +1,6 @@
 // EPOS Cortex Timer Mediator Implementation
 
-#include <machine/ic.h>
+#include <machine/machine.h>
 #include <machine/timer.h>
 
 __BEGIN_SYS
diff --git a/src/machine/pc/pc_timer.cc b/src/machine/pc/pc_timer.cc
index 93168d1..69b6858 100644
--- a/src/machine/pc/pc_timer.cc
+++ b/src/machine/pc/pc_timer.cc
@@ -5,8 +5,10 @@
 
 __BEGIN_SYS
 
+// Class attributes
 Timer * Timer::_channels[CHANNELS];
 
+// Class methods
 void Timer::int_handler(Interrupt_Id i)
 {
     if(_channels[USER] && (--_channels[USER]->_current <= 0)) {
diff --git a/src/machine/riscv/riscv_ic.cc b/src/machine/riscv/riscv_ic.cc
index d3831bd..d96f6a7 100644
--- a/src/machine/riscv/riscv_ic.cc
+++ b/src/machine/riscv/riscv_ic.cc
@@ -23,9 +23,8 @@ void IC::entry()
     // Entry-point for the dummy contexts used by the first dispatching of newly created threads
     ASM("       .global _int_leave              \n"
         "_int_leave:                            \n");
-if(Traits<IC>::hysterically_debugged) {
+if(Traits<IC>::hysterically_debugged)
     ASM("       jalr    %0                      \n" : : "r"(print_context));
-}
 
     // Restore context
     ASM("1:                                     \n");
@@ -59,6 +58,7 @@ void IC::int_not(Interrupt_Id id)
 
 void IC::exception(Interrupt_Id id)
 {
+    CPU::Reg core = CPU::id();
     CPU::Reg epc = CPU::mepc();
     CPU::Reg sp = CPU::sp();
     CPU::Reg status = CPU::mstatus();
@@ -66,7 +66,7 @@ void IC::exception(Interrupt_Id id)
     CPU::Reg tval = CPU::mtval();
     Thread * thread = Thread::self();
 
-    db<IC,System>(WRN) << "IC::Exception(" << id << ") => {" << hex << "thread=" << thread << ",epc=" << epc << ",sp=" << sp << ",status=" << status << ",cause=" << cause << ",tval=" << tval << "}" << dec;
+    db<IC,System>(WRN) << "IC::Exception(" << id << ") => {" << hex << "core=" << core << ",thread=" << thread << ",epc=" << epc << ",sp=" << sp << ",status=" << status << ",cause=" << cause << ",tval=" << tval << "}" << dec;
 
     switch(id) {
     case 0: // unaligned instruction
@@ -115,7 +115,7 @@ void IC::exception(Interrupt_Id id)
     db<IC, System>(WRN) << endl;
 
     if(Traits<Build>::hysterically_debugged)
-        db<IC, System>(ERR) << "Exception stoped execution due to hysterically debuggeing!" << endl;
+        Machine::panic();
 
     CPU::fr(sizeof(void *)); // tell CPU::Context::pop(true) to perform PC = PC + [4|8] on return
 }
diff --git a/src/machine/riscv/riscv_ic_init.cc b/src/machine/riscv/riscv_ic_init.cc
index 2e4b06a..dfc1587 100644
--- a/src/machine/riscv/riscv_ic_init.cc
+++ b/src/machine/riscv/riscv_ic_init.cc
@@ -20,7 +20,7 @@ void IC::init()
 
     // Set all interrupt handlers to int_not()
     for(Interrupt_Id i = EXCS; i < INTS; i++)
-        _int_vector[i] = &int_not;
+        _int_vector[i] = int_not;
 }
 
 __END_SYS
diff --git a/src/machine/riscv/riscv_machine_init.cc b/src/machine/riscv/riscv_machine_init.cc
index cc22b98..1c08646 100644
--- a/src/machine/riscv/riscv_machine_init.cc
+++ b/src/machine/riscv/riscv_machine_init.cc
@@ -4,6 +4,14 @@
 
 __BEGIN_SYS
 
+void Machine::pre_init(System_Info * si)
+{
+    Display::init();
+
+    db<Init, Machine>(TRC) << "Machine::pre_init()" << endl;
+}
+
+
 void Machine::init()
 {
     db<Init, Machine>(TRC) << "Machine::init()" << endl;
diff --git a/src/machine/riscv/riscv_timer.cc b/src/machine/riscv/riscv_timer.cc
index 3c03124..7c461c2 100644
--- a/src/machine/riscv/riscv_timer.cc
+++ b/src/machine/riscv/riscv_timer.cc
@@ -1,6 +1,6 @@
 // EPOS RISC-V Timer Mediator Implementation
 
-#include <machine/ic.h>
+#include <machine/machine.h>
 #include <machine/timer.h>
 
 __BEGIN_SYS
diff --git a/src/setup/setup_legacy_pc.cc b/src/setup/setup_legacy_pc.cc
index 92ef2e6..d2f5707 100644
--- a/src/setup/setup_legacy_pc.cc
+++ b/src/setup/setup_legacy_pc.cc
@@ -88,7 +88,6 @@ private:
     void setup_sys_pt();
     void setup_app_pt();
     void setup_sys_pd();
-    
     void enable_paging();
 
     void load_parts();
@@ -253,13 +252,8 @@ void Setup::build_lm()
         if(!sys_elf->valid())
             db<Setup>(ERR) << "OS ELF image is corrupted!" << endl;
         si->lm.sys_entry = sys_elf->entry();
-        int i = 0;
-        for(; (i < sys_elf->segments()) && (sys_elf->segment_type(i) != PT_LOAD); i++);
-        si->lm.sys_code = sys_elf->segment_address(i);
-        si->lm.sys_code_size = sys_elf->segment_size(i);
-        si->lm.sys_segments = 1;
-        for(i++; i < sys_elf->segments(); i++) {
-            if(sys_elf->segment_type(i) != PT_LOAD)
+        for(int i = 0; i < sys_elf->segments(); i++) {
+            if((sys_elf->segment_size(i) == 0) || (sys_elf->segment_type(i) != PT_LOAD))
                 continue;
             if((sys_elf->segment_address(i) < SYS) || (sys_elf->segment_address(i) > SYS_HIGH)) {
                 db<Setup>(WRN) << "Ignoring ELF segment " << i << " at " << hex << sys_elf->segment_address(i) << "!"<< endl;
@@ -352,8 +346,6 @@ void Setup::build_lm()
         if(si->lm.has_ext) { // Check for EXTRA data in the boot image
             si->lm.app_extra = si->lm.app_data + si->lm.app_data_size;
             si->lm.app_extra_size = si->bm.img_size - si->bm.extras_offset;
-            if(Traits<System>::multiheap)
-                si->lm.app_extra_size = MMU::align_page(si->lm.app_extra_size);
             si->lm.app_data_size += si->lm.app_extra_size;
         }
     }
@@ -476,9 +468,9 @@ void Setup::say_hi()
     kout << "  Mode:         " << ((Traits<Build>::MODE == Traits<Build>::LIBRARY) ? "library" : (Traits<Build>::MODE == Traits<Build>::BUILTIN) ? "built-in" : "kernel") << endl;
     kout << "  Processor:    " << Traits<Machine>::CPUS << " x IA32 at " << Traits<CPU>::CLOCK / 1000000 << " MHz (BUS clock = " << Traits<CPU>::CLOCK / 1000000 << " MHz)" << endl;
     kout << "  Machine:      PC" << endl;
-    kout << "  Memory:       " << (si->bm.mem_top - si->bm.mem_base) / 1024 << " KB [" << reinterpret_cast<void *>(si->bm.mem_base) << ":" << reinterpret_cast<void *>(si->bm.mem_top) << "]" << endl;
-    kout << "  User memory:  " << (si->pmm.usr_mem_top - si->pmm.usr_mem_base) / 1024 << " KB [" << reinterpret_cast<void *>(si->pmm.usr_mem_base) << ":" << reinterpret_cast<void *>(si->pmm.usr_mem_top) << "]" << endl;
-    kout << "  I/O space:    " << (si->bm.mio_top - si->bm.mio_base) / 1024 << " KB [" << reinterpret_cast<void *>(si->bm.mio_base) << ":" << reinterpret_cast<void *>(si->bm.mio_top) << "]" << endl;
+    kout << "  Memory:       " << (si->bm.mem_top - si->bm.mem_base) / 1024 << " KB [" << (void *)si->bm.mem_base << ":" << (void *)si->bm.mem_top << "]" << endl;
+    kout << "  User memory:  " << (si->pmm.usr_mem_top - si->pmm.usr_mem_base) / 1024 << " KB [" << (void *)si->pmm.usr_mem_base << ":" << (void *)si->pmm.usr_mem_top << "]" << endl;
+    kout << "  I/O space:    " << (si->bm.mio_top - si->bm.mio_base) / 1024 << " KB [" << (void *)si->bm.mio_base << ":" << (void *)si->bm.mio_top << "]" << endl;
     kout << "  Node Id:      ";
     if(si->bm.node_id != -1)
         kout << si->bm.node_id << " (" << Traits<Build>::NODES << ")" << endl;
@@ -637,8 +629,6 @@ void Setup::setup_app_pt()
     PT_Entry aux;
 
     // APPLICATION code
-    // Since load_parts() will load the code into memory, the code segment can't be marked R/O yet
-    // The correct flags (APPC and APPD) will be configured after the execution of load_parts(), by adjust_perms()
     for(i = 0, aux = si->pmm.app_code; i < MMU::pages(si->lm.app_code_size); i++, aux = aux + sizeof(Page))
         app_code_pt[MMU::page(si->lm.app_code) + i] = MMU::phy2pte(aux, Flags::APP);
 
@@ -710,7 +700,7 @@ void Setup::setup_sys_pd()
     io_size += VGA_SIZE / sizeof(Page); // add room for VGA (64 kB, 16 pages)
     n_pts = MMU::page_tables(io_size);
 
-    // Map I/O address space into the page tables pointed by io_pts
+    // Map IO address space into the page tables pointed by io_pts
     pts = reinterpret_cast<PT_Entry *>(si->pmm.io_pts);
     unsigned int i = 0;
     for(; i < (APIC_SIZE / sizeof(Page)); i++)
@@ -919,8 +909,9 @@ void Setup::call_next()
     // Note we don't have the original stack here anymore!
     reinterpret_cast<void (*)()>(si->lm.app_entry)();
 
-    // SETUP is now part of the free memory and this point should never be reached, but, just in case ... :-)
-    db<Setup>(ERR) << "OS failed to init!" << endl;
+    // SETUP is now part of the free memory and this point should never be
+    // reached, but, just in case ... :-)
+    panic();
 }
 
 
diff --git a/src/setup/setup_raspberry_pi3.cc b/src/setup/setup_raspberry_pi3.cc
index 7f243b2..5940fdb 100644
--- a/src/setup/setup_raspberry_pi3.cc
+++ b/src/setup/setup_raspberry_pi3.cc
@@ -208,6 +208,7 @@ void Setup::setup_flat_paging()
         (CPU::ATTR_NORMAL_NON_CACHE) << 3 * CPU::ATTR_OFFSET); // second attribute index
 
 #endif
+
 }
 
 
diff --git a/src/setup/setup_realview_pbx.cc b/src/setup/setup_realview_pbx.cc
index 3e16f36..5e30410 100644
--- a/src/setup/setup_realview_pbx.cc
+++ b/src/setup/setup_realview_pbx.cc
@@ -42,6 +42,25 @@ private:
     typedef CPU::Phy_Addr Phy_Addr;
     typedef CPU::Log_Addr Log_Addr;
 
+    enum Section_Flags : unsigned long {
+        ID   = 0b10 << 0,   // memory section identifier
+        B    = 1 << 2,      // bufferable
+        C    = 1 << 3,      // cacheable
+        XN   = 1 << 4,      // execute never
+        AP0  = 1 << 10,
+        AP1  = 1 << 11,
+        TEX0 = 1 << 12,
+        TEX1 = 1 << 13,
+        TEX2 = 1 << 14,
+        AP2  = 1 << 15,
+        S    = 1 << 16,     // shareable
+        nG   = 1 << 17,     // non-global (entry in the TLB)
+        nS   = 1 << 19,     // non-secure
+        FLAT_MEMORY_MEM = (nS | S | AP1 | AP0 |       C | B | ID),
+        FLAT_MEMORY_DEV = (nS | S | AP1 | AP0 |       C |     ID),
+        FLAT_MEMORY_PER = (nS | S | AP1 | AP0 |  XN |     B | ID)
+    };
+
 public:
     Setup();
 
@@ -109,25 +128,6 @@ Setup::Setup()
 
 void Setup::setup_flat_paging()
 {
-    enum Section_Flags : unsigned long {
-        ID   = 0b10 << 0,   // memory section identifier
-        B    = 1 << 2,      // bufferable
-        C    = 1 << 3,      // cacheable
-        XN   = 1 << 4,      // execute never
-        AP0  = 1 << 10,
-        AP1  = 1 << 11,
-        TEX0 = 1 << 12,
-        TEX1 = 1 << 13,
-        TEX2 = 1 << 14,
-        AP2  = 1 << 15,
-        S    = 1 << 16,     // shareable
-        nG   = 1 << 17,     // non-global (entry in the TLB)
-        nS   = 1 << 19,     // non-secure
-        FLAT_MEMORY_MEM = (nS | S | AP1 | AP0 |       C | B | ID),
-        FLAT_MEMORY_DEV = (nS | S | AP1 | AP0 |       C |     ID),
-        FLAT_MEMORY_PER = (nS | S | AP1 | AP0 |  XN |     B | ID)
-    };
-
     // Single level with a single 16KB page table containing 4096 entries, each designating a 1 MB region
     db<Setup>(TRC) << "Setup::setup_flat_paging()" << endl;
 
diff --git a/src/setup/setup_sifive_e.cc b/src/setup/setup_sifive_e.cc
index d5c6df3..442ef31 100644
--- a/src/setup/setup_sifive_e.cc
+++ b/src/setup/setup_sifive_e.cc
@@ -47,6 +47,8 @@ private:
     void say_hi();
     void call_next();
 
+    void panic() { Machine::panic(); }
+
 private:
     System_Info * si;
 };
@@ -78,8 +80,12 @@ void Setup::say_hi()
     db<Setup>(TRC) << "Setup::say_hi()" << endl;
     db<Setup>(INF) << "System_Info=" << *si << endl;
 
-    if(si->bm.application_offset == -1U)
+    kout << endl;
+
+    if(si->bm.application_offset == -1U) {
         db<Setup>(ERR) << "No APPLICATION in boot image, you don't need EPOS!" << endl;
+        panic();
+    }
 
     kout << "This is EPOS!\n" << endl;
     kout << "Setting up this machine as follows: " << endl;
@@ -107,10 +113,15 @@ void Setup::say_hi()
 
 void Setup::call_next()
 {
+    // Check for next stage and obtain the entry point
+    Log_Addr pc;
+
+    pc = &_start;
+
     db<Setup>(INF) << "SETUP ends here!" << endl;
 
-    // Call the next stage
-    static_cast<void (*)()>(&_start)();
+    // Call next stage
+    static_cast<void (*)()>(pc)();
 
     // SETUP is now part of the free memory and this point should never be reached, but, just in case ... :-)
     db<Setup>(ERR) << "OS failed to init!" << endl;
@@ -122,15 +133,13 @@ using namespace EPOS::S;
 
 void _entry() // machine mode
 {
-    CPU::mstatusc(CPU::MIE);                            // disable interrupts (they will be reenabled at Init_End)
-    CPU::mies(CPU::MSI);                                // enable interrupts at CLINT so IPI and timer can be triggered
+    CPU::mstatusc(CPU::MIE);                            // disable interrupts
+    CPU::mies(CPU::MSI | CPU::MTI | CPU::MEI);          // enable interrupts at CLINT so IPI and timer can be triggered
     CLINT::mtvec(CLINT::DIRECT, _int_entry);            // setup a preliminary machine mode interrupt handler pointing it to _int_entry
 
     CPU::sp(Memory_Map::BOOT_STACK + Traits<Machine>::STACK_SIZE - sizeof(long)); // set this hart stack
 
-    Machine::clear_bss();
-
-    CPU::mstatus(CPU::MPP_M);                           // stay in machine mode at mret
+    CPU::mstatus(CPU::MPP_M | CPU::MPIE);               // stay in machine mode and reenable interrupts at mret
 
     CPU::mepc(CPU::Reg(&_setup));                       // entry = _setup
     CPU::mret();                                        // enter supervisor mode at setup (mepc) with interrupts enabled (mstatus.mpie = true)
@@ -138,8 +147,9 @@ void _entry() // machine mode
 
 void _setup() // supervisor mode
 {
-    kerr  << endl;
-    kout  << endl;
+    CPU::mie(CPU::MSI);                                 // enable MSI at CLINT so IPI can be triggered
+
+    Machine::clear_bss();
 
     Setup setup;
 }
diff --git a/src/setup/setup_sifive_u.cc b/src/setup/setup_sifive_u.cc
index 9138244..e9774ad 100644
--- a/src/setup/setup_sifive_u.cc
+++ b/src/setup/setup_sifive_u.cc
@@ -80,6 +80,8 @@ void Setup::say_hi()
     db<Setup>(TRC) << "Setup::say_hi()" << endl;
     db<Setup>(INF) << "System_Info=" << *si << endl;
 
+    kout << endl;
+
     if(si->bm.application_offset == -1U) {
         db<Setup>(ERR) << "No APPLICATION in boot image, you don't need EPOS!" << endl;
         panic();
@@ -88,7 +90,7 @@ void Setup::say_hi()
     kout << "This is EPOS!\n" << endl;
     kout << "Setting up this machine as follows: " << endl;
     kout << "  Mode:         " << ((Traits<Build>::MODE == Traits<Build>::LIBRARY) ? "library" : (Traits<Build>::MODE == Traits<Build>::BUILTIN) ? "built-in" : "kernel") << endl;
-    kout << "  Processor:    " << Traits<Machine>::CPUS << " x RV" << Traits<CPU>::WORD_SIZE << " at " << Traits<CPU>::CLOCK / 1000000 << " MHz (BUS clock = " << Traits<CPU>::CLOCK / 1000000 << " MHz)" << endl;
+    kout << "  Processor:    " << Traits<Machine>::CPUS << " x RV64 at " << Traits<CPU>::CLOCK / 1000000 << " MHz (BUS clock = " << Traits<CPU>::CLOCK / 1000000 << " MHz)" << endl;
     kout << "  Machine:      SiFive-U" << endl;
     kout << "  Memory:       " << (RAM_TOP + 1 - RAM_BASE) / 1024 << " KB [" << reinterpret_cast<void *>(RAM_BASE) << ":" << reinterpret_cast<void *>(RAM_TOP) << "]" << endl;
     kout << "  User memory:  " << (FREE_TOP - FREE_BASE) / 1024 << " KB [" << reinterpret_cast<void *>(FREE_BASE) << ":" << reinterpret_cast<void *>(FREE_TOP) << "]" << endl;
@@ -109,13 +111,17 @@ void Setup::say_hi()
     kout << endl;
 }
 
-
 void Setup::call_next()
 {
+    // Check for next stage and obtain the entry point
+    Log_Addr pc;
+
+    pc = &_start;
+
     db<Setup>(INF) << "SETUP ends here!" << endl;
 
-    // Call the next stage
-    static_cast<void (*)()>(_start)();
+    // Call next stage
+    static_cast<void (*)()>(pc)();
 
     // SETUP is now part of the free memory and this point should never be reached, but, just in case ... :-)
     db<Setup>(ERR) << "OS failed to init!" << endl;
@@ -130,15 +136,13 @@ void _entry() // machine mode
     if(CPU::mhartid() != 0)                             // SiFive-U requires 2 cores, so we disable core 1 here
         CPU::halt();
 
-    CPU::mstatusc(CPU::MIE);                            // disable interrupts (they will be reenabled at Init_End)
-    CPU::mies(CPU::MSI);                                // enable interrupts generation by CLINT
+    CPU::mstatusc(CPU::MIE);                            // disable interrupts
+    CPU::mies(CPU::MSI | CPU::MTI | CPU::MEI);          // enable interrupts at CLINT so IPI and timer can be triggered
     CLINT::mtvec(CLINT::DIRECT, _int_entry);            // setup a preliminary machine mode interrupt handler pointing it to _int_entry
 
-    CPU::sp(Memory_Map::BOOT_STACK + Traits<Machine>::STACK_SIZE - sizeof(long)); // set the stack pointer, thus creating a stack for SETUP
+    CPU::sp(Memory_Map::BOOT_STACK + Traits<Machine>::STACK_SIZE - sizeof(long)); // set this hart stack
 
-    Machine::clear_bss();
-
-    CPU::mstatus(CPU::MPP_M);                           // stay in machine mode at mret
+    CPU::mstatus(CPU::MPP_M | CPU::MPIE);               // stay in machine mode and reenable interrupts at mret
 
     CPU::mepc(CPU::Reg(&_setup));                       // entry = _setup
     CPU::mret();                                        // enter supervisor mode at setup (mepc) with interrupts enabled (mstatus.mpie = true)
@@ -146,8 +150,9 @@ void _entry() // machine mode
 
 void _setup() // supervisor mode
 {
-    kerr  << endl;
-    kout  << endl;
+    CPU::mie(CPU::MSI);                                 // enable MSI at CLINT so IPI can be triggered
+
+    Machine::clear_bss();
 
     Setup setup;
 }
diff --git a/src/setup/setup_zynq.cc b/src/setup/setup_zynq.cc
index 4b9f36b..bdef338 100644
--- a/src/setup/setup_zynq.cc
+++ b/src/setup/setup_zynq.cc
@@ -41,6 +41,25 @@ private:
     typedef CPU::Phy_Addr Phy_Addr;
     typedef CPU::Log_Addr Log_Addr;
 
+    enum Section_Flags : unsigned long {
+        ID   = 0b10 << 0,   // memory section identifier
+        B    = 1 << 2,      // bufferable
+        C    = 1 << 3,      // cacheable
+        XN   = 1 << 4,      // execute never
+        AP0  = 1 << 10,
+        AP1  = 1 << 11,
+        TEX0 = 1 << 12,
+        TEX1 = 1 << 13,
+        TEX2 = 1 << 14,
+        AP2  = 1 << 15,
+        S    = 1 << 16,     // shareable
+        nG   = 1 << 17,     // non-global (entry in the TLB)
+        nS   = 1 << 19,     // non-secure
+        FLAT_MEMORY_MEM = (nS | S | AP1 | AP0 |       C | B | ID),
+        FLAT_MEMORY_DEV = (nS | S | AP1 | AP0 |       C |     ID),
+        FLAT_MEMORY_PER = (nS | S | AP1 | AP0 |  XN |     B | ID)
+    };
+
 public:
     Setup();
 
@@ -95,25 +114,6 @@ Setup::Setup()
 
 void Setup::setup_flat_paging()
 {
-    enum Section_Flags : unsigned long {
-        ID   = 0b10 << 0,   // memory section identifier
-        B    = 1 << 2,      // bufferable
-        C    = 1 << 3,      // cacheable
-        XN   = 1 << 4,      // execute never
-        AP0  = 1 << 10,
-        AP1  = 1 << 11,
-        TEX0 = 1 << 12,
-        TEX1 = 1 << 13,
-        TEX2 = 1 << 14,
-        AP2  = 1 << 15,
-        S    = 1 << 16,     // shareable
-        nG   = 1 << 17,     // non-global (entry in the TLB)
-        nS   = 1 << 19,     // non-secure
-        FLAT_MEMORY_MEM = (nS | S | AP1 | AP0 |       C | B | ID),
-        FLAT_MEMORY_DEV = (nS | S | AP1 | AP0 |       C |     ID),
-        FLAT_MEMORY_PER = (nS | S | AP1 | AP0 |  XN |     B | ID)
-    };
-
     // Single level with a single 16KB page table containing 4096 entries, each designating a 1 MB region
     db<Setup>(TRC) << "Setup::setup_flat_paging()" << endl;
 
diff --git a/tests/active_test/active_test_traits.h b/tests/active_test/active_test_traits.h
index 5328337..aadd8e9 100644
--- a/tests/active_test/active_test_traits.h
+++ b/tests/active_test/active_test_traits.h
@@ -10,9 +10,9 @@ template<> struct Traits<Build>: public Traits_Tokens
 {
     // Basic configuration
     static const unsigned int MODE = LIBRARY;
-    static const unsigned int ARCHITECTURE = RV64;
-    static const unsigned int MACHINE = RISCV;
-    static const unsigned int MODEL = SiFive_U;
+    static const unsigned int ARCHITECTURE = IA32;
+    static const unsigned int MACHINE = PC;
+    static const unsigned int MODEL = Legacy_PC;
     static const unsigned int CPUS = 1;
     static const unsigned int NODES = 1; // (> 1 => NETWORKING)
     static const unsigned int EXPECTED_SIMULATION_TIME = 60; // s (0 => not simulated)
@@ -120,7 +120,7 @@ template<> struct Traits<Thread>: public Traits<Build>
     static const bool enabled = Traits<System>::multithread;
     static const bool trace_idle = hysterically_debugged;
     static const bool simulate_capacity = false;
-    static const unsigned int QUANTUM = 10000; // us
+    static const unsigned int QUANTUM = 1000; // us
 
     typedef RR Criterion;
 };
diff --git a/tests/alarm_test/alarm_test_traits.h b/tests/alarm_test/alarm_test_traits.h
index f4c8d41..af5ea1b 100644
--- a/tests/alarm_test/alarm_test_traits.h
+++ b/tests/alarm_test/alarm_test_traits.h
@@ -10,16 +10,16 @@ template<> struct Traits<Build>: public Traits_Tokens
 {
     // Basic configuration
     static const unsigned int MODE = LIBRARY;
-    static const unsigned int ARCHITECTURE = RV64;
+    static const unsigned int ARCHITECTURE = RV32;
     static const unsigned int MACHINE = RISCV;
-    static const unsigned int MODEL = SiFive_U;
+    static const unsigned int MODEL = SiFive_E; 
     static const unsigned int CPUS = 1;
     static const unsigned int NODES = 1; // (> 1 => NETWORKING)
     static const unsigned int EXPECTED_SIMULATION_TIME = 60; // s (0 => not simulated)
 
     // Default flags
     static const bool enabled = true;
-    static const bool monitored = true;
+    static const bool monitored = false;
     static const bool debugged = true;
     static const bool hysterically_debugged = false;
 
diff --git a/tests/segment_test/segment_test.cc b/tests/segment_test/segment_test.cc
index 71a031b..aa10caa 100644
--- a/tests/segment_test/segment_test.cc
+++ b/tests/segment_test/segment_test.cc
@@ -18,11 +18,6 @@ int main()
 
     cout << "Segment test" << endl;
 
-    if(Traits<Build>::MODEL == Traits<Build>::SiFive_E) {
-        cout << "This test requires multiheap and the SiFive-E doesn't have enough memory to run it!" << endl;
-        return 0;
-    }
-
     cout << "My address space's page directory is located at " << reinterpret_cast<void *>(MMU::current()) << "" << endl;
     Address_Space self(MMU::current());
 
diff --git a/tests/segment_test/segment_test_traits.h b/tests/segment_test/segment_test_traits.h
index ca4d575..a7ecbf0 100644
--- a/tests/segment_test/segment_test_traits.h
+++ b/tests/segment_test/segment_test_traits.h
@@ -10,9 +10,9 @@ template<> struct Traits<Build>: public Traits_Tokens
 {
     // Basic configuration
     static const unsigned int MODE = LIBRARY;
-    static const unsigned int ARCHITECTURE = RV64;
+    static const unsigned int ARCHITECTURE = RV32;
     static const unsigned int MACHINE = RISCV;
-    static const unsigned int MODEL = SiFive_U;
+    static const unsigned int MODEL = SiFive_E; 
     static const unsigned int CPUS = 1;
     static const unsigned int NODES = 1; // (> 1 => NETWORKING)
     static const unsigned int EXPECTED_SIMULATION_TIME = 60; // s (0 => not simulated)
